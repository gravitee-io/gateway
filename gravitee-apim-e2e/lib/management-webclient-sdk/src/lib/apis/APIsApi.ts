/* tslint:disable */
/* eslint-disable */
/**
 * Gravitee.io - Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AlertEventPage,
  AlertStatusEntity,
  AlertTriggerEntity,
  Analytics,
  AnalyticsAverageType,
  AnalyticsType,
  ApiDeploymentEntity,
  ApiEntity,
  ApiGroupsWithMembersMap,
  ApiHeaderEntity,
  ApiKeyEntity,
  ApiListItem,
  ApiListItemPagedResult,
  ApiMembership,
  ApiMetadataEntity,
  ApiMetrics,
  ApiQualityMetricsEntity,
  ApiQualityRuleEntity,
  ApiRequest,
  ApiRequestItemSearchLogResponse,
  ApiStateEntity,
  ApplicationEntity,
  AuditType,
  DebugApiEntity,
  DuplicateApiEntity,
  EventEntity,
  EventEntityPage,
  EventType,
  FormDataBodyPart,
  GenericNotificationConfigEntity,
  HealthcheckField,
  HealthcheckType,
  Hook,
  ImportPageEntity,
  ImportSwaggerDescriptorEntity,
  JsonPatch,
  LifecycleAction,
  Log,
  MemberEntity,
  MembershipListItem,
  MessageEntity,
  MetadataPageAuditEntity,
  NewAlertTriggerEntity,
  NewApiEntity,
  NewApiMetadataEntity,
  NewApiQualityRuleEntity,
  NewPageEntity,
  NewPlanEntity,
  NewRatingAnswerEntity,
  NewRatingEntity,
  NotifierEntity,
  PageEntity,
  PageRatingEntity,
  PageType,
  PlanEntity,
  PlanSecurityType,
  PlanStatus,
  PortalNotificationConfigEntity,
  ProcessSubscriptionEntity,
  PromotionEntity,
  PromotionRequestEntity,
  RatingEntity,
  RatingSummaryEntity,
  ReviewAction,
  ReviewEntity,
  RollbackApiEntity,
  SearchLogResponse,
  Subscription,
  SubscriptionEntityPageResult,
  SubscriptionStatus,
  TransferOwnership,
  TransferSubscriptionEntity,
  UpdateAlertTriggerEntity,
  UpdateApiEntity,
  UpdateApiMetadataEntity,
  UpdateApiQualityRuleEntity,
  UpdatePageEntity,
  UpdatePlanEntity,
  UpdateRatingEntity,
  UpdateSubscriptionEntity,
  VerifyApiParam,
} from '../models';
import {
    AlertEventPageFromJSON,
    AlertEventPageToJSON,
    AlertStatusEntityFromJSON,
    AlertStatusEntityToJSON,
    AlertTriggerEntityFromJSON,
    AlertTriggerEntityToJSON,
    AnalyticsFromJSON,
    AnalyticsToJSON,
    AnalyticsAverageTypeFromJSON,
    AnalyticsAverageTypeToJSON,
    AnalyticsTypeFromJSON,
    AnalyticsTypeToJSON,
    ApiDeploymentEntityFromJSON,
    ApiDeploymentEntityToJSON,
    ApiEntityFromJSON,
    ApiEntityToJSON,
    ApiGroupsWithMembersMapFromJSON,
    ApiGroupsWithMembersMapToJSON,
    ApiHeaderEntityFromJSON,
    ApiHeaderEntityToJSON,
    ApiKeyEntityFromJSON,
    ApiKeyEntityToJSON,
    ApiListItemFromJSON,
    ApiListItemToJSON,
    ApiListItemPagedResultFromJSON,
    ApiListItemPagedResultToJSON,
    ApiMembershipFromJSON,
    ApiMembershipToJSON,
    ApiMetadataEntityFromJSON,
    ApiMetadataEntityToJSON,
    ApiMetricsFromJSON,
    ApiMetricsToJSON,
    ApiQualityMetricsEntityFromJSON,
    ApiQualityMetricsEntityToJSON,
    ApiQualityRuleEntityFromJSON,
    ApiQualityRuleEntityToJSON,
    ApiRequestFromJSON,
    ApiRequestToJSON,
    ApiRequestItemSearchLogResponseFromJSON,
    ApiRequestItemSearchLogResponseToJSON,
    ApiStateEntityFromJSON,
    ApiStateEntityToJSON,
    ApplicationEntityFromJSON,
    ApplicationEntityToJSON,
    AuditTypeFromJSON,
    AuditTypeToJSON,
    DebugApiEntityFromJSON,
    DebugApiEntityToJSON,
    DuplicateApiEntityFromJSON,
    DuplicateApiEntityToJSON,
    EventEntityFromJSON,
    EventEntityToJSON,
    EventEntityPageFromJSON,
    EventEntityPageToJSON,
    EventTypeFromJSON,
    EventTypeToJSON,
    FormDataBodyPartFromJSON,
    FormDataBodyPartToJSON,
    GenericNotificationConfigEntityFromJSON,
    GenericNotificationConfigEntityToJSON,
    HealthcheckFieldFromJSON,
    HealthcheckFieldToJSON,
    HealthcheckTypeFromJSON,
    HealthcheckTypeToJSON,
    HookFromJSON,
    HookToJSON,
    ImportPageEntityFromJSON,
    ImportPageEntityToJSON,
    ImportSwaggerDescriptorEntityFromJSON,
    ImportSwaggerDescriptorEntityToJSON,
    JsonPatchFromJSON,
    JsonPatchToJSON,
    LifecycleActionFromJSON,
    LifecycleActionToJSON,
    LogFromJSON,
    LogToJSON,
    MemberEntityFromJSON,
    MemberEntityToJSON,
    MembershipListItemFromJSON,
    MembershipListItemToJSON,
    MessageEntityFromJSON,
    MessageEntityToJSON,
    MetadataPageAuditEntityFromJSON,
    MetadataPageAuditEntityToJSON,
    NewAlertTriggerEntityFromJSON,
    NewAlertTriggerEntityToJSON,
    NewApiEntityFromJSON,
    NewApiEntityToJSON,
    NewApiMetadataEntityFromJSON,
    NewApiMetadataEntityToJSON,
    NewApiQualityRuleEntityFromJSON,
    NewApiQualityRuleEntityToJSON,
    NewPageEntityFromJSON,
    NewPageEntityToJSON,
    NewPlanEntityFromJSON,
    NewPlanEntityToJSON,
    NewRatingAnswerEntityFromJSON,
    NewRatingAnswerEntityToJSON,
    NewRatingEntityFromJSON,
    NewRatingEntityToJSON,
    NotifierEntityFromJSON,
    NotifierEntityToJSON,
    PageEntityFromJSON,
    PageEntityToJSON,
    PageRatingEntityFromJSON,
    PageRatingEntityToJSON,
    PageTypeFromJSON,
    PageTypeToJSON,
    PlanEntityFromJSON,
    PlanEntityToJSON,
    PlanSecurityTypeFromJSON,
    PlanSecurityTypeToJSON,
    PlanStatusFromJSON,
    PlanStatusToJSON,
    PortalNotificationConfigEntityFromJSON,
    PortalNotificationConfigEntityToJSON,
    ProcessSubscriptionEntityFromJSON,
    ProcessSubscriptionEntityToJSON,
    PromotionEntityFromJSON,
    PromotionEntityToJSON,
    PromotionRequestEntityFromJSON,
    PromotionRequestEntityToJSON,
    RatingEntityFromJSON,
    RatingEntityToJSON,
    RatingSummaryEntityFromJSON,
    RatingSummaryEntityToJSON,
    ReviewActionFromJSON,
    ReviewActionToJSON,
    ReviewEntityFromJSON,
    ReviewEntityToJSON,
    RollbackApiEntityFromJSON,
    RollbackApiEntityToJSON,
    SearchLogResponseFromJSON,
    SearchLogResponseToJSON,
    SubscriptionFromJSON,
    SubscriptionToJSON,
    SubscriptionEntityPageResultFromJSON,
    SubscriptionEntityPageResultToJSON,
    SubscriptionStatusFromJSON,
    SubscriptionStatusToJSON,
    TransferOwnershipFromJSON,
    TransferOwnershipToJSON,
    TransferSubscriptionEntityFromJSON,
    TransferSubscriptionEntityToJSON,
    UpdateAlertTriggerEntityFromJSON,
    UpdateAlertTriggerEntityToJSON,
    UpdateApiEntityFromJSON,
    UpdateApiEntityToJSON,
    UpdateApiMetadataEntityFromJSON,
    UpdateApiMetadataEntityToJSON,
    UpdateApiQualityRuleEntityFromJSON,
    UpdateApiQualityRuleEntityToJSON,
    UpdatePageEntityFromJSON,
    UpdatePageEntityToJSON,
    UpdatePlanEntityFromJSON,
    UpdatePlanEntityToJSON,
    UpdateRatingEntityFromJSON,
    UpdateRatingEntityToJSON,
    UpdateSubscriptionEntityFromJSON,
    UpdateSubscriptionEntityToJSON,
    VerifyApiParamFromJSON,
    VerifyApiParamToJSON,
} from '../models';

export interface AddOrUpdateApiMemberRequest {
    api: string;
    envId: string;
    orgId: string;
    apiMembership: ApiMembership;
}

export interface AttachApiPageMediaRequest {
    page: string;
    api: string;
    envId: string;
    orgId: string;
    file?: FormDataBodyPart;
    fileName?: string;
}

export interface ChangeApiSubscriptionStatusRequest {
    subscription: string;
    status: SubscriptionStatus;
    api: string;
    envId: string;
    orgId: string;
}

export interface CloseApiPlanRequest {
    plan: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface CreateApiRequest {
    envId: string;
    orgId: string;
    newApiEntity: NewApiEntity;
}

export interface CreateApiAlertRequest {
    api: string;
    envId: string;
    orgId: string;
    newAlertTriggerEntity: NewAlertTriggerEntity;
}

export interface CreateApiMessageRequest {
    api: string;
    envId: string;
    orgId: string;
    messageEntity?: MessageEntity;
}

export interface CreateApiMetadataRequest {
    api: string;
    envId: string;
    orgId: string;
    newApiMetadataEntity: NewApiMetadataEntity;
}

export interface CreateApiNotificationSettingsRequest {
    api: string;
    envId: string;
    orgId: string;
    genericNotificationConfigEntity?: GenericNotificationConfigEntity;
}

export interface CreateApiPageRequest {
    api: string;
    envId: string;
    orgId: string;
    newPageEntity: NewPageEntity;
}

export interface CreateApiPlanRequest {
    api: string;
    envId: string;
    orgId: string;
    newPlanEntity: NewPlanEntity;
}

export interface CreateApiQualityRuleRequest {
    api: string;
    envId: string;
    orgId: string;
    newApiQualityRuleEntity: NewApiQualityRuleEntity;
}

export interface CreateApiRatingRequest {
    api: string;
    envId: string;
    orgId: string;
    newRatingEntity: NewRatingEntity;
}

export interface CreateApiRatingAnswerRequest {
    rating: string;
    api: string;
    envId: string;
    orgId: string;
    newRatingAnswerEntity: NewRatingAnswerEntity;
}

export interface CreateSubscriptionToApiRequest {
    application: string;
    plan: string;
    customApiKey?: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface DebugAPIRequest {
    api: string;
    envId: string;
    orgId: string;
    debugApiEntity?: DebugApiEntity;
}

export interface DeleteApiRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface DeleteApiAlertRequest {
    alert: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface DeleteApiMemberRequest {
    user: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface DeleteApiMetadataRequest {
    metadata: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface DeleteApiNotificationSettingsRequest {
    notificationId: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface DeleteApiPageRequest {
    page: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface DeleteApiPlanRequest {
    plan: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface DeleteApiRatingRequest {
    rating: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface DeleteApiRatingAnswerRequest {
    rating: string;
    answer: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface DeployApiRequest {
    api: string;
    envId: string;
    orgId: string;
    apiDeploymentEntity?: ApiDeploymentEntity;
}

export interface DeprecateApiPlanRequest {
    plan: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface DeprecatedUpdateApiWithDefinitionRequest {
    api: string;
    envId: string;
    orgId: string;
    body: any;
}

export interface DeprecatedUpdateApiWithSwaggerRequest {
    api: string;
    envId: string;
    orgId: string;
    importSwaggerDescriptorEntity: ImportSwaggerDescriptorEntity;
}

export interface DepreciateApiPlanRequest {
    plan: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface DoApiLifecycleActionRequest {
    api: string;
    action: LifecycleAction;
    envId: string;
    orgId: string;
}

export interface DoApiReviewActionRequest {
    api: string;
    action: ReviewAction;
    envId: string;
    orgId: string;
    reviewEntity?: ReviewEntity;
}

export interface DuplicateAPIRequest {
    api: string;
    envId: string;
    orgId: string;
    duplicateApiEntity: DuplicateApiEntity;
}

export interface ExportApiDefinitionRequest {
    api: string;
    version?: string;
    exclude?: string;
    envId: string;
    orgId: string;
}

export interface ExportApiLogsAsCSVRequest {
    from?: number;
    to?: number;
    query?: string;
    size?: number;
    page?: number;
    field?: string;
    order?: boolean;
    api: string;
    envId: string;
    orgId: string;
}

export interface ExportApiSubscriptionsLogsAsCSVRequest {
    plan?: Array<string>;
    application?: Array<string>;
    status?: Array<SubscriptionStatus>;
    apiKey?: string;
    size?: number;
    page?: number;
    api: string;
    envId: string;
    orgId: string;
}

export interface FetchAllApiPagesRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface FetchApiPageRequest {
    page: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiAlertEventsRequest {
    alert: string;
    from?: number;
    to?: number;
    page?: number;
    size?: number;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiAlertsRequest {
    eventCounts?: boolean;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiAlertsStatusRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiAnalyticsHitsRequest {
    from?: number;
    to?: number;
    interval?: number;
    query?: string;
    field?: string;
    size?: number;
    type: AnalyticsType;
    ranges?: Array<string>;
    aggs?: Array<string>;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiAuditEventsRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiAuditsRequest {
    environment?: string;
    api?: string;
    application?: string;
    type?: AuditType;
    event?: string;
    from?: number;
    to?: number;
    size?: number;
    page?: number;
    api2: string;
    envId: string;
    orgId: string;
}

export interface GetApiBackgroundRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiDefinitionRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiEventsEventsRequest {
    type?: Array<EventType>;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiFlowSchemaFormRequest {
    envId: string;
    orgId: string;
}

export interface GetApiGroupsWithMembersRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiHealthRequest {
    type?: HealthcheckType;
    field?: HealthcheckField;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiHealthAverageRequest {
    from?: number;
    to?: number;
    interval?: number;
    type: AnalyticsAverageType;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiHealthCheckLogRequest {
    log: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiHealthCheckLogsRequest {
    from?: number;
    to?: number;
    query?: string;
    size?: number;
    page?: number;
    transition?: boolean;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiHooksRequest {
    envId: string;
    orgId: string;
}

export interface GetApiKeysForApiSubscriptionRequest {
    subscription: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiLogRequest {
    log: string;
    timestamp?: number;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiLogsRequest {
    from?: number;
    to?: number;
    query?: string;
    size?: number;
    page?: number;
    field?: string;
    order?: boolean;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiMediaImageRequest {
    api: string;
    hash: string;
    envId: string;
    orgId: string;
}

export interface GetApiMembersRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiMembersPermissionsRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiMetadataRequest {
    metadata: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiMetadatasRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiNotificationSettingsRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiNotifiersRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiPageRequest {
    page: string;
    acceptLanguage?: string;
    portal?: boolean;
    translated?: boolean;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiPageContentRequest {
    page: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiPageMediaRequest {
    page: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiPagesRequest {
    acceptLanguage?: string;
    homepage?: boolean;
    type?: PageType;
    parent?: string;
    name?: string;
    root?: boolean;
    translated?: boolean;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiPictureRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiPlanRequest {
    plan: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiPlansRequest {
    status?: Array<PlanStatus>;
    security?: Array<PlanSecurityType>;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiQualityMetricsRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiQualityRulesRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiRatingRequest {
    pageNumber?: number;
    pageSize?: number;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiRatingByApiAndUserRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiRatingSummaryByApiRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiSubscribersRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiSubscriptionRequest {
    subscription: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApiSubscriptionsRequest {
    plan?: Array<string>;
    application?: Array<string>;
    status?: Array<SubscriptionStatus>;
    apiKey?: string;
    size?: number;
    page?: number;
    expand?: Array<GetApiSubscriptionsExpandEnum>;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetApisRequest {
    category?: string;
    group?: string;
    top?: boolean;
    contextPath?: string;
    label?: string;
    state?: string;
    visibility?: string;
    version?: string;
    executionMode?: GetApisExecutionModeEnum;
    name?: string;
    tag?: string;
    portal?: boolean;
    crossId?: string;
    envId: string;
    orgId: string;
}

export interface GetApisPagedRequest {
    category?: string;
    group?: string;
    top?: boolean;
    contextPath?: string;
    label?: string;
    state?: string;
    visibility?: string;
    version?: string;
    executionMode?: GetApisPagedExecutionModeEnum;
    name?: string;
    tag?: string;
    portal?: boolean;
    crossId?: string;
    size?: number;
    page?: number;
    envId: string;
    orgId: string;
}

export interface GetEventRequest {
    eventId: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetPlatformAlertsAnalyticsRequest {
    from?: number;
    to?: number;
    api: string;
    envId: string;
    orgId: string;
}

export interface GetPortalApiHeadersRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface ImportApiDefinitionRequest {
    definitionVersion?: string;
    envId: string;
    orgId: string;
    body: any;
}

export interface ImportApiDefinitionUrlRequest {
    definitionVersion?: string;
    envId: string;
    orgId: string;
    body: string;
}

export interface ImportApiPageFilesRequest {
    api: string;
    envId: string;
    orgId: string;
    importPageEntity: ImportPageEntity;
}

export interface ImportApiPathMappingsFromPageRequest {
    api: string;
    page: string;
    definitionVersion?: string;
    envId: string;
    orgId: string;
}

export interface ImportSwaggerApiRequest {
    definitionVersion?: string;
    envId: string;
    orgId: string;
    importSwaggerDescriptorEntity: ImportSwaggerDescriptorEntity;
}

export interface IsApiSynchronizedRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface MigrateAPIRequest {
    api: string;
    envId: string;
    orgId: string;
}

export interface PartialUpdateApiPageRequest {
    page: string;
    api: string;
    envId: string;
    orgId: string;
    updatePageEntity?: UpdatePageEntity;
}

export interface PatchRequest {
    dryRun?: boolean;
    api: string;
    envId: string;
    orgId: string;
    jsonPatch: Array<JsonPatch>;
}

export interface ProcessApiSubscriptionRequest {
    subscription: string;
    api: string;
    envId: string;
    orgId: string;
    processSubscriptionEntity: ProcessSubscriptionEntity;
}

export interface PromoteAPIRequest {
    api: string;
    envId: string;
    orgId: string;
    promotionRequestEntity: PromotionRequestEntity;
}

export interface PublishApiPlanRequest {
    plan: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface ReactivateApiKeyForApiSubscriptionRequest {
    apikey: string;
    subscription: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface RenewSubscriptionApiKeysForApiSubscriptionRequest {
    subscription: string;
    customApiKey?: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface RevokeApiKeyForApiSubscriptionRequest {
    apikey: string;
    subscription: string;
    api: string;
    envId: string;
    orgId: string;
}

export interface RollbackApiRequest {
    api: string;
    envId: string;
    orgId: string;
    rollbackApiEntity: RollbackApiEntity;
}

export interface SearchApiEventsRequest {
    type?: Array<EventType>;
    from?: number;
    to?: number;
    page?: number;
    size?: number;
    apiIds?: Array<string>;
    api: string;
    envId: string;
    orgId: string;
}

export interface SearchApisRequest {
    q: string;
    envId: string;
    orgId: string;
}

export interface SearchPagedApisRequest {
    q: string;
    order?: string;
    size?: number;
    page?: number;
    envId: string;
    orgId: string;
}

export interface TransferApiMemberOwnershipRequest {
    api: string;
    envId: string;
    orgId: string;
    transferOwnership: TransferOwnership;
}

export interface TransferApiSubscriptionRequest {
    subscription: string;
    api: string;
    envId: string;
    orgId: string;
    transferSubscriptionEntity: TransferSubscriptionEntity;
}

export interface UpdateApiRequest {
    api: string;
    envId: string;
    orgId: string;
    updateApiEntity: UpdateApiEntity;
}

export interface UpdateApiAlertRequest {
    alert: string;
    api: string;
    envId: string;
    orgId: string;
    updateAlertTriggerEntity: UpdateAlertTriggerEntity;
}

export interface UpdateApiGeneralNotificationSettingsRequest {
    notificationId: string;
    api: string;
    envId: string;
    orgId: string;
    genericNotificationConfigEntity?: GenericNotificationConfigEntity;
}

export interface UpdateApiKeyForApiSubscriptionRequest {
    apikey: string;
    subscription: string;
    api: string;
    envId: string;
    orgId: string;
    apiKeyEntity: ApiKeyEntity;
}

export interface UpdateApiMetadataRequest {
    metadata: string;
    api: string;
    envId: string;
    orgId: string;
    updateApiMetadataEntity: UpdateApiMetadataEntity;
}

export interface UpdateApiPageRequest {
    page: string;
    api: string;
    envId: string;
    orgId: string;
    updatePageEntity: UpdatePageEntity;
}

export interface UpdateApiPageImportFilesRequest {
    api: string;
    envId: string;
    orgId: string;
    importPageEntity: ImportPageEntity;
}

export interface UpdateApiPlanRequest {
    plan: string;
    api: string;
    envId: string;
    orgId: string;
    updatePlanEntity: UpdatePlanEntity;
}

export interface UpdateApiPortalNotificationSettingsRequest {
    api: string;
    envId: string;
    orgId: string;
    portalNotificationConfigEntity?: PortalNotificationConfigEntity;
}

export interface UpdateApiQualityRuleRequest {
    qualityRule: string;
    api: string;
    envId: string;
    orgId: string;
    updateApiQualityRuleEntity: UpdateApiQualityRuleEntity;
}

export interface UpdateApiRatingRequest {
    rating: string;
    api: string;
    envId: string;
    orgId: string;
    updateRatingEntity: UpdateRatingEntity;
}

export interface UpdateApiSubscriptionRequest {
    subscription: string;
    api: string;
    envId: string;
    orgId: string;
    updateSubscriptionEntity: UpdateSubscriptionEntity;
}

export interface UpdateApiWithDefinitionRequest {
    api: string;
    envId: string;
    orgId: string;
    body: any;
}

export interface UpdateApiWithSwaggerPUTRequest {
    api: string;
    definitionVersion?: string;
    envId: string;
    orgId: string;
    importSwaggerDescriptorEntity: ImportSwaggerDescriptorEntity;
}

export interface UpdateApiWithUrlRequest {
    api: string;
    envId: string;
    orgId: string;
    body: string;
}

export interface UpdatePageContentRequest {
    page: string;
    api: string;
    envId: string;
    orgId: string;
    body: string;
}

export interface UpdateWithDefinitionRequest {
    envId: string;
    orgId: string;
    body: any;
}

export interface UploadApiMediaImageRequest {
    api: string;
    envId: string;
    orgId: string;
    file?: FormDataBodyPart;
}

export interface VerifyApiRequest {
    envId: string;
    orgId: string;
    verifyApiParam?: VerifyApiParam;
}

export interface VerifyApiKeyCreationRequest {
    key: string;
    application: string;
    api: string;
    envId: string;
    orgId: string;
}

/**
 * 
 */
export class APIsApi extends runtime.BaseAPI {

    /**
     * User must have the MANAGE_MEMBERS permission to use this service
     * Add or update an API member
     */
    async addOrUpdateApiMemberRaw(requestParameters: AddOrUpdateApiMemberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling addOrUpdateApiMember.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling addOrUpdateApiMember.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling addOrUpdateApiMember.');
        }

        if (requestParameters.apiMembership === null || requestParameters.apiMembership === undefined) {
            throw new runtime.RequiredError('apiMembership','Required parameter requestParameters.apiMembership was null or undefined when calling addOrUpdateApiMember.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/members`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApiMembershipToJSON(requestParameters.apiMembership),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGE_MEMBERS permission to use this service
     * Add or update an API member
     */
    async addOrUpdateApiMember(requestParameters: AddOrUpdateApiMemberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addOrUpdateApiMemberRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the API_DOCUMENTATION[UPDATE] permission to use this service
     * Attach a media to an API page 
     */
    async attachApiPageMediaRaw(requestParameters: AttachApiPageMediaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageEntity>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling attachApiPageMedia.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling attachApiPageMedia.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling attachApiPageMedia.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling attachApiPageMedia.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', new Blob([JSON.stringify(FormDataBodyPartToJSON(requestParameters.file))], { type: "application/json", }));
                    }

        if (requestParameters.fileName !== undefined) {
            formParams.append('fileName', requestParameters.fileName as any);
        }

        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages/{page}/media`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PageEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_DOCUMENTATION[UPDATE] permission to use this service
     * Attach a media to an API page 
     */
    async attachApiPageMedia(requestParameters: AttachApiPageMediaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageEntity> {
        const response = await this.attachApiPageMediaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Change the status of a subscription
     */
    async changeApiSubscriptionStatusRaw(requestParameters: ChangeApiSubscriptionStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.subscription === null || requestParameters.subscription === undefined) {
            throw new runtime.RequiredError('subscription','Required parameter requestParameters.subscription was null or undefined when calling changeApiSubscriptionStatus.');
        }

        if (requestParameters.status === null || requestParameters.status === undefined) {
            throw new runtime.RequiredError('status','Required parameter requestParameters.status was null or undefined when calling changeApiSubscriptionStatus.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling changeApiSubscriptionStatus.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling changeApiSubscriptionStatus.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling changeApiSubscriptionStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions/{subscription}/status`.replace(`{${"subscription"}}`, encodeURIComponent(String(requestParameters.subscription))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Change the status of a subscription
     */
    async changeApiSubscriptionStatus(requestParameters: ChangeApiSubscriptionStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Subscription> {
        const response = await this.changeApiSubscriptionStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Close  a plan
     */
    async closeApiPlanRaw(requestParameters: CloseApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlanEntity>> {
        if (requestParameters.plan === null || requestParameters.plan === undefined) {
            throw new runtime.RequiredError('plan','Required parameter requestParameters.plan was null or undefined when calling closeApiPlan.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling closeApiPlan.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling closeApiPlan.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling closeApiPlan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/plans/{plan}/_close`.replace(`{${"plan"}}`, encodeURIComponent(String(requestParameters.plan))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlanEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Close  a plan
     */
    async closeApiPlan(requestParameters: CloseApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlanEntity> {
        const response = await this.closeApiPlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have API_PUBLISHER or ADMIN role to create an API.
     * Create an API
     */
    async createApiRaw(requestParameters: CreateApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createApi.');
        }

        if (requestParameters.newApiEntity === null || requestParameters.newApiEntity === undefined) {
            throw new runtime.RequiredError('newApiEntity','Required parameter requestParameters.newApiEntity was null or undefined when calling createApi.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewApiEntityToJSON(requestParameters.newApiEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have API_PUBLISHER or ADMIN role to create an API.
     * Create an API
     */
    async createApi(requestParameters: CreateApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.createApiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_ALERT[CREATE] permission to use this service
     * Create an alert for an API
     */
    async createApiAlertRaw(requestParameters: CreateApiAlertRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertTriggerEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling createApiAlert.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createApiAlert.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createApiAlert.');
        }

        if (requestParameters.newAlertTriggerEntity === null || requestParameters.newAlertTriggerEntity === undefined) {
            throw new runtime.RequiredError('newAlertTriggerEntity','Required parameter requestParameters.newAlertTriggerEntity was null or undefined when calling createApiAlert.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/alerts`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewAlertTriggerEntityToJSON(requestParameters.newAlertTriggerEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertTriggerEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_ALERT[CREATE] permission to use this service
     * Create an alert for an API
     */
    async createApiAlert(requestParameters: CreateApiAlertRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertTriggerEntity> {
        const response = await this.createApiAlertRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_MESSAGE[CREATE] permission to use this service
     * Send a message to existing consumers of an API
     */
    async createApiMessageRaw(requestParameters: CreateApiMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<number>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling createApiMessage.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createApiMessage.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createApiMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/messages`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MessageEntityToJSON(requestParameters.messageEntity),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * User must have the API_MESSAGE[CREATE] permission to use this service
     * Send a message to existing consumers of an API
     */
    async createApiMessage(requestParameters: CreateApiMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<number> {
        const response = await this.createApiMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_METADATA[CREATE] permission to use this service
     * Create an API metadata
     */
    async createApiMetadataRaw(requestParameters: CreateApiMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiMetadataEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling createApiMetadata.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createApiMetadata.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createApiMetadata.');
        }

        if (requestParameters.newApiMetadataEntity === null || requestParameters.newApiMetadataEntity === undefined) {
            throw new runtime.RequiredError('newApiMetadataEntity','Required parameter requestParameters.newApiMetadataEntity was null or undefined when calling createApiMetadata.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/metadata`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewApiMetadataEntityToJSON(requestParameters.newApiMetadataEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiMetadataEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_METADATA[CREATE] permission to use this service
     * Create an API metadata
     */
    async createApiMetadata(requestParameters: CreateApiMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiMetadataEntity> {
        const response = await this.createApiMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create notification settings
     */
    async createApiNotificationSettingsRaw(requestParameters: CreateApiNotificationSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling createApiNotificationSettings.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createApiNotificationSettings.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createApiNotificationSettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/notificationsettings`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenericNotificationConfigEntityToJSON(requestParameters.genericNotificationConfigEntity),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Create notification settings
     */
    async createApiNotificationSettings(requestParameters: CreateApiNotificationSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.createApiNotificationSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Create a page
     */
    async createApiPageRaw(requestParameters: CreateApiPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling createApiPage.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createApiPage.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createApiPage.');
        }

        if (requestParameters.newPageEntity === null || requestParameters.newPageEntity === undefined) {
            throw new runtime.RequiredError('newPageEntity','Required parameter requestParameters.newPageEntity was null or undefined when calling createApiPage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewPageEntityToJSON(requestParameters.newPageEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PageEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Create a page
     */
    async createApiPage(requestParameters: CreateApiPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageEntity> {
        const response = await this.createApiPageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Create a plan
     */
    async createApiPlanRaw(requestParameters: CreateApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlanEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling createApiPlan.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createApiPlan.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createApiPlan.');
        }

        if (requestParameters.newPlanEntity === null || requestParameters.newPlanEntity === undefined) {
            throw new runtime.RequiredError('newPlanEntity','Required parameter requestParameters.newPlanEntity was null or undefined when calling createApiPlan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/plans`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewPlanEntityToJSON(requestParameters.newPlanEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlanEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Create a plan
     */
    async createApiPlan(requestParameters: CreateApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlanEntity> {
        const response = await this.createApiPlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_QUALITY_RULE[CREATE] permission to use this service
     * Create a new quality rules for an API
     */
    async createApiQualityRuleRaw(requestParameters: CreateApiQualityRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiQualityRuleEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling createApiQualityRule.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createApiQualityRule.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createApiQualityRule.');
        }

        if (requestParameters.newApiQualityRuleEntity === null || requestParameters.newApiQualityRuleEntity === undefined) {
            throw new runtime.RequiredError('newApiQualityRuleEntity','Required parameter requestParameters.newApiQualityRuleEntity was null or undefined when calling createApiQualityRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/quality-rules`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewApiQualityRuleEntityToJSON(requestParameters.newApiQualityRuleEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiQualityRuleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_QUALITY_RULE[CREATE] permission to use this service
     * Create a new quality rules for an API
     */
    async createApiQualityRule(requestParameters: CreateApiQualityRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiQualityRuleEntity> {
        const response = await this.createApiQualityRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_RATING[CREATE] permission to use this service
     * Create a new rating for an API
     */
    async createApiRatingRaw(requestParameters: CreateApiRatingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RatingEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling createApiRating.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createApiRating.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createApiRating.');
        }

        if (requestParameters.newRatingEntity === null || requestParameters.newRatingEntity === undefined) {
            throw new runtime.RequiredError('newRatingEntity','Required parameter requestParameters.newRatingEntity was null or undefined when calling createApiRating.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/ratings`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewRatingEntityToJSON(requestParameters.newRatingEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RatingEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_RATING[CREATE] permission to use this service
     * Create a new rating for an API
     */
    async createApiRating(requestParameters: CreateApiRatingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RatingEntity> {
        const response = await this.createApiRatingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_RATING_ANSWER[CREATE] permission to use this service
     * Create an answer to a rating for an API
     */
    async createApiRatingAnswerRaw(requestParameters: CreateApiRatingAnswerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RatingEntity>> {
        if (requestParameters.rating === null || requestParameters.rating === undefined) {
            throw new runtime.RequiredError('rating','Required parameter requestParameters.rating was null or undefined when calling createApiRatingAnswer.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling createApiRatingAnswer.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createApiRatingAnswer.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createApiRatingAnswer.');
        }

        if (requestParameters.newRatingAnswerEntity === null || requestParameters.newRatingAnswerEntity === undefined) {
            throw new runtime.RequiredError('newRatingAnswerEntity','Required parameter requestParameters.newRatingAnswerEntity was null or undefined when calling createApiRatingAnswer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/ratings/{rating}/answers`.replace(`{${"rating"}}`, encodeURIComponent(String(requestParameters.rating))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewRatingAnswerEntityToJSON(requestParameters.newRatingAnswerEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RatingEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_RATING_ANSWER[CREATE] permission to use this service
     * Create an answer to a rating for an API
     */
    async createApiRatingAnswer(requestParameters: CreateApiRatingAnswerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RatingEntity> {
        const response = await this.createApiRatingAnswerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_SUBSCRIPTIONS permission to use this service
     * Subscribe to a plan
     */
    async createSubscriptionToApiRaw(requestParameters: CreateSubscriptionToApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.application === null || requestParameters.application === undefined) {
            throw new runtime.RequiredError('application','Required parameter requestParameters.application was null or undefined when calling createSubscriptionToApi.');
        }

        if (requestParameters.plan === null || requestParameters.plan === undefined) {
            throw new runtime.RequiredError('plan','Required parameter requestParameters.plan was null or undefined when calling createSubscriptionToApi.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling createSubscriptionToApi.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createSubscriptionToApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createSubscriptionToApi.');
        }

        const queryParameters: any = {};

        if (requestParameters.application !== undefined) {
            queryParameters['application'] = requestParameters.application;
        }

        if (requestParameters.plan !== undefined) {
            queryParameters['plan'] = requestParameters.plan;
        }

        if (requestParameters.customApiKey !== undefined) {
            queryParameters['customApiKey'] = requestParameters.customApiKey;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_SUBSCRIPTIONS permission to use this service
     * Subscribe to a plan
     */
    async createSubscriptionToApi(requestParameters: CreateSubscriptionToApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Subscription> {
        const response = await this.createSubscriptionToApiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the UPDATE permission on API_DEFINITION to use this service
     * Debug an API on gateway instances
     */
    async debugAPIRaw(requestParameters: DebugAPIRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EventEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling debugAPI.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling debugAPI.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling debugAPI.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/_debug`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DebugApiEntityToJSON(requestParameters.debugApiEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventEntityFromJSON(jsonValue));
    }

    /**
     * User must have the UPDATE permission on API_DEFINITION to use this service
     * Debug an API on gateway instances
     */
    async debugAPI(requestParameters: DebugAPIRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EventEntity> {
        const response = await this.debugAPIRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the DELETE permission to use this service
     * Delete the API
     */
    async deleteApiRaw(requestParameters: DeleteApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deleteApi.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteApi.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the DELETE permission to use this service
     * Delete the API
     */
    async deleteApi(requestParameters: DeleteApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteApiRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the API_ALERT[DELETE] permission to use this service
     * Delete an alert for an API
     */
    async deleteApiAlertRaw(requestParameters: DeleteApiAlertRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertTriggerEntity>> {
        if (requestParameters.alert === null || requestParameters.alert === undefined) {
            throw new runtime.RequiredError('alert','Required parameter requestParameters.alert was null or undefined when calling deleteApiAlert.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deleteApiAlert.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteApiAlert.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteApiAlert.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/alerts/{alert}`.replace(`{${"alert"}}`, encodeURIComponent(String(requestParameters.alert))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertTriggerEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_ALERT[DELETE] permission to use this service
     * Delete an alert for an API
     */
    async deleteApiAlert(requestParameters: DeleteApiAlertRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertTriggerEntity> {
        const response = await this.deleteApiAlertRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_MEMBERS permission to use this service
     * Remove an API member
     */
    async deleteApiMemberRaw(requestParameters: DeleteApiMemberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.user === null || requestParameters.user === undefined) {
            throw new runtime.RequiredError('user','Required parameter requestParameters.user was null or undefined when calling deleteApiMember.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deleteApiMember.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteApiMember.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteApiMember.');
        }

        const queryParameters: any = {};

        if (requestParameters.user !== undefined) {
            queryParameters['user'] = requestParameters.user;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/members`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGE_MEMBERS permission to use this service
     * Remove an API member
     */
    async deleteApiMember(requestParameters: DeleteApiMemberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteApiMemberRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the API_METADATA[DELETE] permission to use this service
     * Delete a metadata
     */
    async deleteApiMetadataRaw(requestParameters: DeleteApiMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.metadata === null || requestParameters.metadata === undefined) {
            throw new runtime.RequiredError('metadata','Required parameter requestParameters.metadata was null or undefined when calling deleteApiMetadata.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deleteApiMetadata.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteApiMetadata.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteApiMetadata.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/metadata/{metadata}`.replace(`{${"metadata"}}`, encodeURIComponent(String(requestParameters.metadata))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the API_METADATA[DELETE] permission to use this service
     * Delete a metadata
     */
    async deleteApiMetadata(requestParameters: DeleteApiMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteApiMetadataRaw(requestParameters, initOverrides);
    }

    /**
     * Delete notification settings
     */
    async deleteApiNotificationSettingsRaw(requestParameters: DeleteApiNotificationSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.notificationId === null || requestParameters.notificationId === undefined) {
            throw new runtime.RequiredError('notificationId','Required parameter requestParameters.notificationId was null or undefined when calling deleteApiNotificationSettings.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deleteApiNotificationSettings.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteApiNotificationSettings.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteApiNotificationSettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/notificationsettings/{notificationId}`.replace(`{${"notificationId"}}`, encodeURIComponent(String(requestParameters.notificationId))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete notification settings
     */
    async deleteApiNotificationSettings(requestParameters: DeleteApiNotificationSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteApiNotificationSettingsRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Delete a page
     */
    async deleteApiPageRaw(requestParameters: DeleteApiPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling deleteApiPage.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deleteApiPage.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteApiPage.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteApiPage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages/{page}`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Delete a page
     */
    async deleteApiPage(requestParameters: DeleteApiPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteApiPageRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Delete a plan
     */
    async deleteApiPlanRaw(requestParameters: DeleteApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.plan === null || requestParameters.plan === undefined) {
            throw new runtime.RequiredError('plan','Required parameter requestParameters.plan was null or undefined when calling deleteApiPlan.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deleteApiPlan.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteApiPlan.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteApiPlan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/plans/{plan}`.replace(`{${"plan"}}`, encodeURIComponent(String(requestParameters.plan))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Delete a plan
     */
    async deleteApiPlan(requestParameters: DeleteApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteApiPlanRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the API_RATING[DELETE] permission to use this service
     * Delete an existing rating for an API
     */
    async deleteApiRatingRaw(requestParameters: DeleteApiRatingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.rating === null || requestParameters.rating === undefined) {
            throw new runtime.RequiredError('rating','Required parameter requestParameters.rating was null or undefined when calling deleteApiRating.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deleteApiRating.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteApiRating.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteApiRating.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/ratings/{rating}`.replace(`{${"rating"}}`, encodeURIComponent(String(requestParameters.rating))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the API_RATING[DELETE] permission to use this service
     * Delete an existing rating for an API
     */
    async deleteApiRating(requestParameters: DeleteApiRatingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteApiRatingRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the API_RATING_ANSWER[DELETE] permission to use this service
     * Delete an answer to a rating for an API
     */
    async deleteApiRatingAnswerRaw(requestParameters: DeleteApiRatingAnswerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.rating === null || requestParameters.rating === undefined) {
            throw new runtime.RequiredError('rating','Required parameter requestParameters.rating was null or undefined when calling deleteApiRatingAnswer.');
        }

        if (requestParameters.answer === null || requestParameters.answer === undefined) {
            throw new runtime.RequiredError('answer','Required parameter requestParameters.answer was null or undefined when calling deleteApiRatingAnswer.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deleteApiRatingAnswer.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteApiRatingAnswer.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteApiRatingAnswer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/ratings/{rating}/answers/{answer}`.replace(`{${"rating"}}`, encodeURIComponent(String(requestParameters.rating))).replace(`{${"answer"}}`, encodeURIComponent(String(requestParameters.answer))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the API_RATING_ANSWER[DELETE] permission to use this service
     * Delete an answer to a rating for an API
     */
    async deleteApiRatingAnswer(requestParameters: DeleteApiRatingAnswerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteApiRatingAnswerRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the MANAGE_LIFECYCLE permission to use this service
     * Deploy API to gateway instances
     */
    async deployApiRaw(requestParameters: DeployApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deployApi.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deployApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deployApi.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/deploy`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApiDeploymentEntityToJSON(requestParameters.apiDeploymentEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_LIFECYCLE permission to use this service
     * Deploy API to gateway instances
     */
    async deployApi(requestParameters: DeployApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.deployApiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_PLAN[UPDATE] permission to use this service
     * Deprecate a plan
     */
    async deprecateApiPlanRaw(requestParameters: DeprecateApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlanEntity>> {
        if (requestParameters.plan === null || requestParameters.plan === undefined) {
            throw new runtime.RequiredError('plan','Required parameter requestParameters.plan was null or undefined when calling deprecateApiPlan.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deprecateApiPlan.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deprecateApiPlan.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deprecateApiPlan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/plans/{plan}/_deprecate`.replace(`{${"plan"}}`, encodeURIComponent(String(requestParameters.plan))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlanEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_PLAN[UPDATE] permission to use this service
     * Deprecate a plan
     */
    async deprecateApiPlan(requestParameters: DeprecateApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlanEntity> {
        const response = await this.deprecateApiPlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Deprecated, Update the API with an existing API definition in JSON format either with json or via an URL
     */
    async deprecatedUpdateApiWithDefinitionRaw(requestParameters: DeprecatedUpdateApiWithDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deprecatedUpdateApiWithDefinition.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deprecatedUpdateApiWithDefinition.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deprecatedUpdateApiWithDefinition.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deprecatedUpdateApiWithDefinition.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/import`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Deprecated, Update the API with an existing API definition in JSON format either with json or via an URL
     */
    async deprecatedUpdateApiWithDefinition(requestParameters: DeprecatedUpdateApiWithDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.deprecatedUpdateApiWithDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Deprecated, use PUT method instead. Update the API with an existing Swagger descriptor
     */
    async deprecatedUpdateApiWithSwaggerRaw(requestParameters: DeprecatedUpdateApiWithSwaggerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling deprecatedUpdateApiWithSwagger.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deprecatedUpdateApiWithSwagger.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deprecatedUpdateApiWithSwagger.');
        }

        if (requestParameters.importSwaggerDescriptorEntity === null || requestParameters.importSwaggerDescriptorEntity === undefined) {
            throw new runtime.RequiredError('importSwaggerDescriptorEntity','Required parameter requestParameters.importSwaggerDescriptorEntity was null or undefined when calling deprecatedUpdateApiWithSwagger.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/import/swagger`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImportSwaggerDescriptorEntityToJSON(requestParameters.importSwaggerDescriptorEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Deprecated, use PUT method instead. Update the API with an existing Swagger descriptor
     */
    async deprecatedUpdateApiWithSwagger(requestParameters: DeprecatedUpdateApiWithSwaggerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.deprecatedUpdateApiWithSwaggerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_PLAN[UPDATE] permission to use this service
     * Deprecated, use \'_deprecate\' instead. Deprecate a plan
     */
    async depreciateApiPlanRaw(requestParameters: DepreciateApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlanEntity>> {
        if (requestParameters.plan === null || requestParameters.plan === undefined) {
            throw new runtime.RequiredError('plan','Required parameter requestParameters.plan was null or undefined when calling depreciateApiPlan.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling depreciateApiPlan.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling depreciateApiPlan.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling depreciateApiPlan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/plans/{plan}/_depreciate`.replace(`{${"plan"}}`, encodeURIComponent(String(requestParameters.plan))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlanEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_PLAN[UPDATE] permission to use this service
     * Deprecated, use \'_deprecate\' instead. Deprecate a plan
     */
    async depreciateApiPlan(requestParameters: DepreciateApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlanEntity> {
        const response = await this.depreciateApiPlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_LIFECYCLE permission to use this service
     * Manage the API\'s lifecycle
     */
    async doApiLifecycleActionRaw(requestParameters: DoApiLifecycleActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling doApiLifecycleAction.');
        }

        if (requestParameters.action === null || requestParameters.action === undefined) {
            throw new runtime.RequiredError('action','Required parameter requestParameters.action was null or undefined when calling doApiLifecycleAction.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling doApiLifecycleAction.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling doApiLifecycleAction.');
        }

        const queryParameters: any = {};

        if (requestParameters.action !== undefined) {
            queryParameters['action'] = requestParameters.action;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGE_LIFECYCLE permission to use this service
     * Manage the API\'s lifecycle
     */
    async doApiLifecycleAction(requestParameters: DoApiLifecycleActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.doApiLifecycleActionRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the API_DEFINITION[UPDATE] or API_REVIEWS[UPDATE] permission to use this service (depending on the action)
     * Manage the API\'s review state
     */
    async doApiReviewActionRaw(requestParameters: DoApiReviewActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling doApiReviewAction.');
        }

        if (requestParameters.action === null || requestParameters.action === undefined) {
            throw new runtime.RequiredError('action','Required parameter requestParameters.action was null or undefined when calling doApiReviewAction.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling doApiReviewAction.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling doApiReviewAction.');
        }

        const queryParameters: any = {};

        if (requestParameters.action !== undefined) {
            queryParameters['action'] = requestParameters.action;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/reviews`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReviewEntityToJSON(requestParameters.reviewEntity),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the API_DEFINITION[UPDATE] or API_REVIEWS[UPDATE] permission to use this service (depending on the action)
     * Manage the API\'s review state
     */
    async doApiReviewAction(requestParameters: DoApiReviewActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.doApiReviewActionRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the MANAGE_API create permission to use this service
     * Duplicate the API
     */
    async duplicateAPIRaw(requestParameters: DuplicateAPIRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling duplicateAPI.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling duplicateAPI.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling duplicateAPI.');
        }

        if (requestParameters.duplicateApiEntity === null || requestParameters.duplicateApiEntity === undefined) {
            throw new runtime.RequiredError('duplicateApiEntity','Required parameter requestParameters.duplicateApiEntity was null or undefined when calling duplicateAPI.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/duplicate`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DuplicateApiEntityToJSON(requestParameters.duplicateApiEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_API create permission to use this service
     * Duplicate the API
     */
    async duplicateAPI(requestParameters: DuplicateAPIRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.duplicateAPIRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Export the API definition in JSON format
     */
    async exportApiDefinitionRaw(requestParameters: ExportApiDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling exportApiDefinition.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling exportApiDefinition.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling exportApiDefinition.');
        }

        const queryParameters: any = {};

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        if (requestParameters.exclude !== undefined) {
            queryParameters['exclude'] = requestParameters.exclude;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/export`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Export the API definition in JSON format
     */
    async exportApiDefinition(requestParameters: ExportApiDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.exportApiDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export API logs as CSV
     */
    async exportApiLogsAsCSVRaw(requestParameters: ExportApiLogsAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling exportApiLogsAsCSV.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling exportApiLogsAsCSV.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling exportApiLogsAsCSV.');
        }

        const queryParameters: any = {};

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.field !== undefined) {
            queryParameters['field'] = requestParameters.field;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/logs/export`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Export API logs as CSV
     */
    async exportApiLogsAsCSV(requestParameters: ExportApiLogsAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportApiLogsAsCSVRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export API logs as CSV
     */
    async exportApiSubscriptionsLogsAsCSVRaw(requestParameters: ExportApiSubscriptionsLogsAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling exportApiSubscriptionsLogsAsCSV.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling exportApiSubscriptionsLogsAsCSV.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling exportApiSubscriptionsLogsAsCSV.');
        }

        const queryParameters: any = {};

        if (requestParameters.plan) {
            queryParameters['plan'] = requestParameters.plan.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.application) {
            queryParameters['application'] = requestParameters.application.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.status) {
            queryParameters['status'] = requestParameters.status.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.apiKey !== undefined) {
            queryParameters['api_key'] = requestParameters.apiKey;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions/export`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Export API logs as CSV
     */
    async exportApiSubscriptionsLogsAsCSV(requestParameters: ExportApiSubscriptionsLogsAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportApiSubscriptionsLogsAsCSVRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Refresh all pages by calling their associated fetcher
     */
    async fetchAllApiPagesRaw(requestParameters: FetchAllApiPagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling fetchAllApiPages.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling fetchAllApiPages.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling fetchAllApiPages.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages/_fetch`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PageEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Refresh all pages by calling their associated fetcher
     */
    async fetchAllApiPages(requestParameters: FetchAllApiPagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageEntity> {
        const response = await this.fetchAllApiPagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Refresh page by calling the associated fetcher
     */
    async fetchApiPageRaw(requestParameters: FetchApiPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageEntity>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling fetchApiPage.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling fetchApiPage.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling fetchApiPage.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling fetchApiPage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages/{page}/_fetch`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PageEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Refresh page by calling the associated fetcher
     */
    async fetchApiPage(requestParameters: FetchApiPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageEntity> {
        const response = await this.fetchApiPageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the READ permission on the API_DEFINITION to use this service on a private API.
     * Get the API
     */
    async getApiRaw(requestParameters: GetApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApi.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApi.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have the READ permission on the API_DEFINITION to use this service on a private API.
     * Get the API
     */
    async getApi(requestParameters: GetApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.getApiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ALERT[READ] permission to use this service
     * Retrieve the list of events for an alert
     */
    async getApiAlertEventsRaw(requestParameters: GetApiAlertEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertEventPage>> {
        if (requestParameters.alert === null || requestParameters.alert === undefined) {
            throw new runtime.RequiredError('alert','Required parameter requestParameters.alert was null or undefined when calling getApiAlertEvents.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiAlertEvents.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiAlertEvents.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiAlertEvents.');
        }

        const queryParameters: any = {};

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/alerts/{alert}/events`.replace(`{${"alert"}}`, encodeURIComponent(String(requestParameters.alert))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertEventPageFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ALERT[READ] permission to use this service
     * Retrieve the list of events for an alert
     */
    async getApiAlertEvents(requestParameters: GetApiAlertEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertEventPage> {
        const response = await this.getApiAlertEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_ALERT[READ] permission to use this service
     * List alerts of an API
     */
    async getApiAlertsRaw(requestParameters: GetApiAlertsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AlertTriggerEntity>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiAlerts.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiAlerts.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiAlerts.');
        }

        const queryParameters: any = {};

        if (requestParameters.eventCounts !== undefined) {
            queryParameters['event_counts'] = requestParameters.eventCounts;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/alerts`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AlertTriggerEntityFromJSON));
    }

    /**
     * User must have the API_ALERT[READ] permission to use this service
     * List alerts of an API
     */
    async getApiAlerts(requestParameters: GetApiAlertsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AlertTriggerEntity>> {
        const response = await this.getApiAlertsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGEMENT_ALERT[READ] permission to use this service
     * Get alerting status
     */
    async getApiAlertsStatusRaw(requestParameters: GetApiAlertsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertStatusEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiAlertsStatus.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiAlertsStatus.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiAlertsStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/alerts/status`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertStatusEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGEMENT_ALERT[READ] permission to use this service
     * Get alerting status
     */
    async getApiAlertsStatus(requestParameters: GetApiAlertsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertStatusEntity> {
        const response = await this.getApiAlertsStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_ANALYTICS[READ] permission to use this service
     * Get API analytics
     */
    async getApiAnalyticsHitsRaw(requestParameters: GetApiAnalyticsHitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Analytics>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getApiAnalyticsHits.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiAnalyticsHits.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiAnalyticsHits.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiAnalyticsHits.');
        }

        const queryParameters: any = {};

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        if (requestParameters.interval !== undefined) {
            queryParameters['interval'] = requestParameters.interval;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.field !== undefined) {
            queryParameters['field'] = requestParameters.field;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.ranges) {
            queryParameters['ranges'] = requestParameters.ranges.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.aggs) {
            queryParameters['aggs'] = requestParameters.aggs.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/analytics`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalyticsFromJSON(jsonValue));
    }

    /**
     * User must have the API_ANALYTICS[READ] permission to use this service
     * Get API analytics
     */
    async getApiAnalyticsHits(requestParameters: GetApiAnalyticsHitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Analytics> {
        const response = await this.getApiAnalyticsHitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_AUDIT[READ] permission to use this service
     * List available audit event type for API
     */
    async getApiAuditEventsRaw(requestParameters: GetApiAuditEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiAuditEvents.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiAuditEvents.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiAuditEvents.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/audit/events`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the API_AUDIT[READ] permission to use this service
     * List available audit event type for API
     */
    async getApiAuditEvents(requestParameters: GetApiAuditEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getApiAuditEventsRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the API_AUDIT[READ] permission to use this service
     * Retrieve audit logs for the API
     */
    async getApiAuditsRaw(requestParameters: GetApiAuditsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MetadataPageAuditEntity>> {
        if (requestParameters.api2 === null || requestParameters.api2 === undefined) {
            throw new runtime.RequiredError('api2','Required parameter requestParameters.api2 was null or undefined when calling getApiAudits.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiAudits.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiAudits.');
        }

        const queryParameters: any = {};

        if (requestParameters.environment !== undefined) {
            queryParameters['environment'] = requestParameters.environment;
        }

        if (requestParameters.api !== undefined) {
            queryParameters['api'] = requestParameters.api;
        }

        if (requestParameters.application !== undefined) {
            queryParameters['application'] = requestParameters.application;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.event !== undefined) {
            queryParameters['event'] = requestParameters.event;
        }

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/audit`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api2))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MetadataPageAuditEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_AUDIT[READ] permission to use this service
     * Retrieve audit logs for the API
     */
    async getApiAudits(requestParameters: GetApiAuditsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MetadataPageAuditEntity> {
        const response = await this.getApiAuditsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the READ permission to use this service
     * Get the API\'s background
     */
    async getApiBackgroundRaw(requestParameters: GetApiBackgroundRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiBackground.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiBackground.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiBackground.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/background`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * User must have the READ permission to use this service
     * Get the API\'s background
     */
    async getApiBackground(requestParameters: GetApiBackgroundRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getApiBackgroundRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_DEFINITION[READ] permission to use this service
     * Export the API definition in JSON format
     */
    async getApiDefinitionRaw(requestParameters: GetApiDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiDefinition.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiDefinition.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiDefinition.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/definition`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * User must have the API_DEFINITION[READ] permission to use this service
     * Export the API definition in JSON format
     */
    async getApiDefinition(requestParameters: GetApiDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getApiDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_LIFECYCLE permission to use this service
     * Get API\'s events
     */
    async getApiEventsEventsRaw(requestParameters: GetApiEventsEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EventEntity>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiEventsEvents.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiEventsEvents.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiEventsEvents.');
        }

        const queryParameters: any = {};

        if (requestParameters.type) {
            queryParameters['type'] = requestParameters.type.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/events`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventEntityFromJSON));
    }

    /**
     * User must have the MANAGE_LIFECYCLE permission to use this service
     * Get API\'s events
     */
    async getApiEventsEvents(requestParameters: GetApiEventsEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EventEntity>> {
        const response = await this.getApiEventsEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the API configuration schema
     */
    async getApiFlowSchemaFormRaw(requestParameters: GetApiFlowSchemaFormRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiFlowSchemaForm.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiFlowSchemaForm.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/schema`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get the API configuration schema
     */
    async getApiFlowSchemaForm(requestParameters: GetApiFlowSchemaFormRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.getApiFlowSchemaFormRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_MEMBERS permission to use this service
     * Get API groups mapped to members
     */
    async getApiGroupsWithMembersRaw(requestParameters: GetApiGroupsWithMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiGroupsWithMembersMap>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiGroupsWithMembers.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiGroupsWithMembers.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiGroupsWithMembers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/groups`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiGroupsWithMembersMapFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_MEMBERS permission to use this service
     * Get API groups mapped to members
     */
    async getApiGroupsWithMembers(requestParameters: GetApiGroupsWithMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiGroupsWithMembersMap> {
        const response = await this.getApiGroupsWithMembersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Health-check statistics for API
     */
    async getApiHealthRaw(requestParameters: GetApiHealthRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiMetrics>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiHealth.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiHealth.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiHealth.');
        }

        const queryParameters: any = {};

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.field !== undefined) {
            queryParameters['field'] = requestParameters.field;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/health`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiMetricsFromJSON(jsonValue));
    }

    /**
     * Health-check statistics for API
     */
    async getApiHealth(requestParameters: GetApiHealthRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiMetrics> {
        const response = await this.getApiHealthRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Health-check average statistics for API
     */
    async getApiHealthAverageRaw(requestParameters: GetApiHealthAverageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getApiHealthAverage.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiHealthAverage.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiHealthAverage.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiHealthAverage.');
        }

        const queryParameters: any = {};

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        if (requestParameters.interval !== undefined) {
            queryParameters['interval'] = requestParameters.interval;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/health/average`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Health-check average statistics for API
     */
    async getApiHealthAverage(requestParameters: GetApiHealthAverageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getApiHealthAverageRaw(requestParameters, initOverrides);
    }

    /**
     * Health-check log
     */
    async getApiHealthCheckLogRaw(requestParameters: GetApiHealthCheckLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Log>> {
        if (requestParameters.log === null || requestParameters.log === undefined) {
            throw new runtime.RequiredError('log','Required parameter requestParameters.log was null or undefined when calling getApiHealthCheckLog.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiHealthCheckLog.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiHealthCheckLog.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiHealthCheckLog.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/health/logs/{log}`.replace(`{${"log"}}`, encodeURIComponent(String(requestParameters.log))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LogFromJSON(jsonValue));
    }

    /**
     * Health-check log
     */
    async getApiHealthCheckLog(requestParameters: GetApiHealthCheckLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Log> {
        const response = await this.getApiHealthCheckLogRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Health-check logs
     */
    async getApiHealthCheckLogsRaw(requestParameters: GetApiHealthCheckLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchLogResponse>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiHealthCheckLogs.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiHealthCheckLogs.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiHealthCheckLogs.');
        }

        const queryParameters: any = {};

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.transition !== undefined) {
            queryParameters['transition'] = requestParameters.transition;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/health/logs`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchLogResponseFromJSON(jsonValue));
    }

    /**
     * Health-check logs
     */
    async getApiHealthCheckLogs(requestParameters: GetApiHealthCheckLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchLogResponse> {
        const response = await this.getApiHealthCheckLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the list of available hooks
     */
    async getApiHooksRaw(requestParameters: GetApiHooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Hook>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiHooks.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiHooks.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/hooks`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(HookFromJSON));
    }

    /**
     * Get the list of available hooks
     */
    async getApiHooks(requestParameters: GetApiHooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Hook>> {
        const response = await this.getApiHooksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_API_KEYS permission to use this service
     * List all API Keys for a subscription
     */
    async getApiKeysForApiSubscriptionRaw(requestParameters: GetApiKeysForApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApiKeyEntity>>> {
        if (requestParameters.subscription === null || requestParameters.subscription === undefined) {
            throw new runtime.RequiredError('subscription','Required parameter requestParameters.subscription was null or undefined when calling getApiKeysForApiSubscription.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiKeysForApiSubscription.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiKeysForApiSubscription.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiKeysForApiSubscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions/{subscription}/apikeys`.replace(`{${"subscription"}}`, encodeURIComponent(String(requestParameters.subscription))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApiKeyEntityFromJSON));
    }

    /**
     * User must have the MANAGE_API_KEYS permission to use this service
     * List all API Keys for a subscription
     */
    async getApiKeysForApiSubscription(requestParameters: GetApiKeysForApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApiKeyEntity>> {
        const response = await this.getApiKeysForApiSubscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a specific log
     */
    async getApiLogRaw(requestParameters: GetApiLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiRequest>> {
        if (requestParameters.log === null || requestParameters.log === undefined) {
            throw new runtime.RequiredError('log','Required parameter requestParameters.log was null or undefined when calling getApiLog.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiLog.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiLog.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiLog.');
        }

        const queryParameters: any = {};

        if (requestParameters.timestamp !== undefined) {
            queryParameters['timestamp'] = requestParameters.timestamp;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/logs/{log}`.replace(`{${"log"}}`, encodeURIComponent(String(requestParameters.log))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiRequestFromJSON(jsonValue));
    }

    /**
     * Get a specific log
     */
    async getApiLog(requestParameters: GetApiLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiRequest> {
        const response = await this.getApiLogRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get API logs
     */
    async getApiLogsRaw(requestParameters: GetApiLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiRequestItemSearchLogResponse>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiLogs.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiLogs.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiLogs.');
        }

        const queryParameters: any = {};

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.field !== undefined) {
            queryParameters['field'] = requestParameters.field;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/logs`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiRequestItemSearchLogResponseFromJSON(jsonValue));
    }

    /**
     * Get API logs
     */
    async getApiLogs(requestParameters: GetApiLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiRequestItemSearchLogResponse> {
        const response = await this.getApiLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a media for an API
     */
    async getApiMediaImageRaw(requestParameters: GetApiMediaImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiMediaImage.');
        }

        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling getApiMediaImage.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiMediaImage.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiMediaImage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/media/{hash}`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve a media for an API
     */
    async getApiMediaImage(requestParameters: GetApiMediaImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getApiMediaImageRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the MANAGE_MEMBERS permission to use this service
     * List API members
     */
    async getApiMembersRaw(requestParameters: GetApiMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MembershipListItem>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiMembers.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiMembers.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiMembers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/members`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MembershipListItemFromJSON));
    }

    /**
     * User must have the MANAGE_MEMBERS permission to use this service
     * List API members
     */
    async getApiMembers(requestParameters: GetApiMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MembershipListItem>> {
        const response = await this.getApiMembersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_MEMBERS permission to use this service
     * Get API members
     */
    async getApiMembersPermissionsRaw(requestParameters: GetApiMembersPermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MemberEntity>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiMembersPermissions.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiMembersPermissions.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiMembersPermissions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/members/permissions`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MemberEntityFromJSON));
    }

    /**
     * User must have the MANAGE_MEMBERS permission to use this service
     * Get API members
     */
    async getApiMembersPermissions(requestParameters: GetApiMembersPermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MemberEntity>> {
        const response = await this.getApiMembersPermissionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_METADATA[READ] permission to use this service
     * A metadata for the given API and metadata id
     */
    async getApiMetadataRaw(requestParameters: GetApiMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiMetadataEntity>> {
        if (requestParameters.metadata === null || requestParameters.metadata === undefined) {
            throw new runtime.RequiredError('metadata','Required parameter requestParameters.metadata was null or undefined when calling getApiMetadata.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiMetadata.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiMetadata.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiMetadata.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/metadata/{metadata}`.replace(`{${"metadata"}}`, encodeURIComponent(String(requestParameters.metadata))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiMetadataEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_METADATA[READ] permission to use this service
     * A metadata for the given API and metadata id
     */
    async getApiMetadata(requestParameters: GetApiMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiMetadataEntity> {
        const response = await this.getApiMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_METADATA[READ] permission to use this service
     * List metadata for the given API
     */
    async getApiMetadatasRaw(requestParameters: GetApiMetadatasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApiMetadataEntity>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiMetadatas.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiMetadatas.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiMetadatas.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/metadata`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApiMetadataEntityFromJSON));
    }

    /**
     * User must have the API_METADATA[READ] permission to use this service
     * List metadata for the given API
     */
    async getApiMetadatas(requestParameters: GetApiMetadatasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApiMetadataEntity>> {
        const response = await this.getApiMetadatasRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get notification settings
     */
    async getApiNotificationSettingsRaw(requestParameters: GetApiNotificationSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<any>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiNotificationSettings.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiNotificationSettings.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiNotificationSettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/notificationsettings`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get notification settings
     */
    async getApiNotificationSettings(requestParameters: GetApiNotificationSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<any>> {
        const response = await this.getApiNotificationSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_NOTIFICATION[READ] permission to use this service
     * List available notifiers for API
     */
    async getApiNotifiersRaw(requestParameters: GetApiNotifiersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<NotifierEntity>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiNotifiers.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiNotifiers.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiNotifiers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/notifiers`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(NotifierEntityFromJSON));
    }

    /**
     * User must have the API_NOTIFICATION[READ] permission to use this service
     * List available notifiers for API
     */
    async getApiNotifiers(requestParameters: GetApiNotifiersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<NotifierEntity>> {
        const response = await this.getApiNotifiersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the READ permission to use this service
     * Get a page
     */
    async getApiPageRaw(requestParameters: GetApiPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageEntity>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling getApiPage.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiPage.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiPage.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiPage.');
        }

        const queryParameters: any = {};

        if (requestParameters.portal !== undefined) {
            queryParameters['portal'] = requestParameters.portal;
        }

        if (requestParameters.translated !== undefined) {
            queryParameters['translated'] = requestParameters.translated;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages/{page}`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PageEntityFromJSON(jsonValue));
    }

    /**
     * User must have the READ permission to use this service
     * Get a page
     */
    async getApiPage(requestParameters: GetApiPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageEntity> {
        const response = await this.getApiPageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the READ permission to use this service
     * Get the page\'s content
     */
    async getApiPageContentRaw(requestParameters: GetApiPageContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling getApiPageContent.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiPageContent.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiPageContent.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiPageContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages/{page}/content`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * User must have the READ permission to use this service
     * Get the page\'s content
     */
    async getApiPageContent(requestParameters: GetApiPageContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.getApiPageContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_DOCUMENTATION[READ] permission to use this service
     * Retrieve all media for an API page
     */
    async getApiPageMediaRaw(requestParameters: GetApiPageMediaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling getApiPageMedia.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiPageMedia.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiPageMedia.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiPageMedia.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages/{page}/media`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the API_DOCUMENTATION[READ] permission to use this service
     * Retrieve all media for an API page
     */
    async getApiPageMedia(requestParameters: GetApiPageMediaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getApiPageMediaRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the READ permission to use this service
     * List pages
     */
    async getApiPagesRaw(requestParameters: GetApiPagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PageEntity>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiPages.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiPages.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiPages.');
        }

        const queryParameters: any = {};

        if (requestParameters.homepage !== undefined) {
            queryParameters['homepage'] = requestParameters.homepage;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.parent !== undefined) {
            queryParameters['parent'] = requestParameters.parent;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.root !== undefined) {
            queryParameters['root'] = requestParameters.root;
        }

        if (requestParameters.translated !== undefined) {
            queryParameters['translated'] = requestParameters.translated;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PageEntityFromJSON));
    }

    /**
     * User must have the READ permission to use this service
     * List pages
     */
    async getApiPages(requestParameters: GetApiPagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PageEntity>> {
        const response = await this.getApiPagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the READ permission to use this service
     * Get the API\'s picture
     */
    async getApiPictureRaw(requestParameters: GetApiPictureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiPicture.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiPicture.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiPicture.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/picture`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * User must have the READ permission to use this service
     * Get the API\'s picture
     */
    async getApiPicture(requestParameters: GetApiPictureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getApiPictureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the READ permission to use this service
     * Get a plan
     */
    async getApiPlanRaw(requestParameters: GetApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlanEntity>> {
        if (requestParameters.plan === null || requestParameters.plan === undefined) {
            throw new runtime.RequiredError('plan','Required parameter requestParameters.plan was null or undefined when calling getApiPlan.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiPlan.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiPlan.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiPlan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/plans/{plan}`.replace(`{${"plan"}}`, encodeURIComponent(String(requestParameters.plan))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlanEntityFromJSON(jsonValue));
    }

    /**
     * User must have the READ permission to use this service
     * Get a plan
     */
    async getApiPlan(requestParameters: GetApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlanEntity> {
        const response = await this.getApiPlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all the plans accessible to the current user.
     * List plans for an API
     */
    async getApiPlansRaw(requestParameters: GetApiPlansRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PlanEntity>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiPlans.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiPlans.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiPlans.');
        }

        const queryParameters: any = {};

        if (requestParameters.status) {
            queryParameters['status'] = requestParameters.status.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.security) {
            queryParameters['security'] = requestParameters.security.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/plans`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PlanEntityFromJSON));
    }

    /**
     * List all the plans accessible to the current user.
     * List plans for an API
     */
    async getApiPlans(requestParameters: GetApiPlansRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PlanEntity>> {
        const response = await this.getApiPlansRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the quality metrics of the API
     */
    async getApiQualityMetricsRaw(requestParameters: GetApiQualityMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiQualityMetricsEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiQualityMetrics.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiQualityMetrics.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiQualityMetrics.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/quality`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiQualityMetricsEntityFromJSON(jsonValue));
    }

    /**
     * Get the quality metrics of the API
     */
    async getApiQualityMetrics(requestParameters: GetApiQualityMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiQualityMetricsEntity> {
        const response = await this.getApiQualityMetricsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_QUALITY_RULE[READ] permission to use this service
     * List quality rules for an API
     */
    async getApiQualityRulesRaw(requestParameters: GetApiQualityRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApiQualityRuleEntity>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiQualityRules.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiQualityRules.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiQualityRules.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/quality-rules`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApiQualityRuleEntityFromJSON));
    }

    /**
     * User must have the API_QUALITY_RULE[READ] permission to use this service
     * List quality rules for an API
     */
    async getApiQualityRules(requestParameters: GetApiQualityRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApiQualityRuleEntity>> {
        const response = await this.getApiQualityRulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List ratings for an API
     */
    async getApiRatingRaw(requestParameters: GetApiRatingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageRatingEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiRating.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiRating.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiRating.');
        }

        const queryParameters: any = {};

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['pageNumber'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/ratings`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PageRatingEntityFromJSON(jsonValue));
    }

    /**
     * List ratings for an API
     */
    async getApiRating(requestParameters: GetApiRatingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageRatingEntity> {
        const response = await this.getApiRatingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve current rating for an API provided by the authenticated user
     */
    async getApiRatingByApiAndUserRaw(requestParameters: GetApiRatingByApiAndUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RatingEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiRatingByApiAndUser.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiRatingByApiAndUser.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiRatingByApiAndUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/ratings/current`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RatingEntityFromJSON(jsonValue));
    }

    /**
     * Retrieve current rating for an API provided by the authenticated user
     */
    async getApiRatingByApiAndUser(requestParameters: GetApiRatingByApiAndUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RatingEntity> {
        const response = await this.getApiRatingByApiAndUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the rating summary for an API
     */
    async getApiRatingSummaryByApiRaw(requestParameters: GetApiRatingSummaryByApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RatingSummaryEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiRatingSummaryByApi.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiRatingSummaryByApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiRatingSummaryByApi.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/ratings/summary`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RatingSummaryEntityFromJSON(jsonValue));
    }

    /**
     * Get the rating summary for an API
     */
    async getApiRatingSummaryByApi(requestParameters: GetApiRatingSummaryByApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RatingSummaryEntity> {
        const response = await this.getApiRatingSummaryByApiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_SUBSCRIPTIONS permission to use this service
     * List subscribers for the API
     */
    async getApiSubscribersRaw(requestParameters: GetApiSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApplicationEntity>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiSubscribers.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiSubscribers.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiSubscribers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscribers`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApplicationEntityFromJSON));
    }

    /**
     * User must have the MANAGE_SUBSCRIPTIONS permission to use this service
     * List subscribers for the API
     */
    async getApiSubscribers(requestParameters: GetApiSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApplicationEntity>> {
        const response = await this.getApiSubscribersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Get a subscription
     */
    async getApiSubscriptionRaw(requestParameters: GetApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.subscription === null || requestParameters.subscription === undefined) {
            throw new runtime.RequiredError('subscription','Required parameter requestParameters.subscription was null or undefined when calling getApiSubscription.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiSubscription.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiSubscription.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiSubscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions/{subscription}`.replace(`{${"subscription"}}`, encodeURIComponent(String(requestParameters.subscription))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Get a subscription
     */
    async getApiSubscription(requestParameters: GetApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Subscription> {
        const response = await this.getApiSubscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the READ_SUBSCRIPTION permission to use this service
     * List subscriptions for the API
     */
    async getApiSubscriptionsRaw(requestParameters: GetApiSubscriptionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubscriptionEntityPageResult>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getApiSubscriptions.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApiSubscriptions.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApiSubscriptions.');
        }

        const queryParameters: any = {};

        if (requestParameters.plan) {
            queryParameters['plan'] = requestParameters.plan.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.application) {
            queryParameters['application'] = requestParameters.application.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.status) {
            queryParameters['status'] = requestParameters.status.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.apiKey !== undefined) {
            queryParameters['api_key'] = requestParameters.apiKey;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.expand) {
            queryParameters['expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionEntityPageResultFromJSON(jsonValue));
    }

    /**
     * User must have the READ_SUBSCRIPTION permission to use this service
     * List subscriptions for the API
     */
    async getApiSubscriptions(requestParameters: GetApiSubscriptionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubscriptionEntityPageResult> {
        const response = await this.getApiSubscriptionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all the APIs accessible to the current user.
     * List APIs
     */
    async getApisRaw(requestParameters: GetApisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApiListItem>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApis.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApis.');
        }

        const queryParameters: any = {};

        if (requestParameters.category !== undefined) {
            queryParameters['category'] = requestParameters.category;
        }

        if (requestParameters.group !== undefined) {
            queryParameters['group'] = requestParameters.group;
        }

        if (requestParameters.top !== undefined) {
            queryParameters['top'] = requestParameters.top;
        }

        if (requestParameters.contextPath !== undefined) {
            queryParameters['context-path'] = requestParameters.contextPath;
        }

        if (requestParameters.label !== undefined) {
            queryParameters['label'] = requestParameters.label;
        }

        if (requestParameters.state !== undefined) {
            queryParameters['state'] = requestParameters.state;
        }

        if (requestParameters.visibility !== undefined) {
            queryParameters['visibility'] = requestParameters.visibility;
        }

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        if (requestParameters.executionMode !== undefined) {
            queryParameters['executionMode'] = requestParameters.executionMode;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.tag !== undefined) {
            queryParameters['tag'] = requestParameters.tag;
        }

        if (requestParameters.portal !== undefined) {
            queryParameters['portal'] = requestParameters.portal;
        }

        if (requestParameters.crossId !== undefined) {
            queryParameters['crossId'] = requestParameters.crossId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApiListItemFromJSON));
    }

    /**
     * List all the APIs accessible to the current user.
     * List APIs
     */
    async getApis(requestParameters: GetApisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApiListItem>> {
        const response = await this.getApisRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all the APIs accessible to the current user with pagination.
     * List APIs with pagination
     */
    async getApisPagedRaw(requestParameters: GetApisPagedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiListItemPagedResult>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getApisPaged.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getApisPaged.');
        }

        const queryParameters: any = {};

        if (requestParameters.category !== undefined) {
            queryParameters['category'] = requestParameters.category;
        }

        if (requestParameters.group !== undefined) {
            queryParameters['group'] = requestParameters.group;
        }

        if (requestParameters.top !== undefined) {
            queryParameters['top'] = requestParameters.top;
        }

        if (requestParameters.contextPath !== undefined) {
            queryParameters['context-path'] = requestParameters.contextPath;
        }

        if (requestParameters.label !== undefined) {
            queryParameters['label'] = requestParameters.label;
        }

        if (requestParameters.state !== undefined) {
            queryParameters['state'] = requestParameters.state;
        }

        if (requestParameters.visibility !== undefined) {
            queryParameters['visibility'] = requestParameters.visibility;
        }

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        if (requestParameters.executionMode !== undefined) {
            queryParameters['executionMode'] = requestParameters.executionMode;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.tag !== undefined) {
            queryParameters['tag'] = requestParameters.tag;
        }

        if (requestParameters.portal !== undefined) {
            queryParameters['portal'] = requestParameters.portal;
        }

        if (requestParameters.crossId !== undefined) {
            queryParameters['crossId'] = requestParameters.crossId;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/_paged`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiListItemPagedResultFromJSON(jsonValue));
    }

    /**
     * List all the APIs accessible to the current user with pagination.
     * List APIs with pagination
     */
    async getApisPaged(requestParameters: GetApisPagedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiListItemPagedResult> {
        const response = await this.getApisPagedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the READ API_EVENT permission to use this service
     * Get an API event with its id
     */
    async getEventRaw(requestParameters: GetEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EventEntity>> {
        if (requestParameters.eventId === null || requestParameters.eventId === undefined) {
            throw new runtime.RequiredError('eventId','Required parameter requestParameters.eventId was null or undefined when calling getEvent.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getEvent.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getEvent.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getEvent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/events/{eventId}`.replace(`{${"eventId"}}`, encodeURIComponent(String(requestParameters.eventId))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventEntityFromJSON(jsonValue));
    }

    /**
     * User must have the READ API_EVENT permission to use this service
     * Get an API event with its id
     */
    async getEvent(requestParameters: GetEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EventEntity> {
        const response = await this.getEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_ALERT[READ] permission to use this service
     * List configured alerts of the API
     */
    async getPlatformAlertsAnalyticsRaw(requestParameters: GetPlatformAlertsAnalyticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AlertTriggerEntity>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getPlatformAlertsAnalytics.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getPlatformAlertsAnalytics.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getPlatformAlertsAnalytics.');
        }

        const queryParameters: any = {};

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/alerts/analytics`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AlertTriggerEntityFromJSON));
    }

    /**
     * User must have the API_ALERT[READ] permission to use this service
     * List configured alerts of the API
     */
    async getPlatformAlertsAnalytics(requestParameters: GetPlatformAlertsAnalyticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AlertTriggerEntity>> {
        const response = await this.getPlatformAlertsAnalyticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the portal API headers values
     */
    async getPortalApiHeadersRaw(requestParameters: GetPortalApiHeadersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApiHeaderEntity>>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling getPortalApiHeaders.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getPortalApiHeaders.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getPortalApiHeaders.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/headers`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApiHeaderEntityFromJSON));
    }

    /**
     * Get the portal API headers values
     */
    async getPortalApiHeaders(requestParameters: GetPortalApiHeadersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApiHeaderEntity>> {
        const response = await this.getPortalApiHeadersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an API by importing an existing API definition in JSON format.
     * Create an API by importing an API definition
     */
    async importApiDefinitionRaw(requestParameters: ImportApiDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling importApiDefinition.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling importApiDefinition.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling importApiDefinition.');
        }

        const queryParameters: any = {};

        if (requestParameters.definitionVersion !== undefined) {
            queryParameters['definitionVersion'] = requestParameters.definitionVersion;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/import`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * Create an API by importing an existing API definition in JSON format.
     * Create an API by importing an API definition
     */
    async importApiDefinition(requestParameters: ImportApiDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.importApiDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an API by importing an existing API definition via a URL
     * Create an API by importing a URL pointing to an API definition
     */
    async importApiDefinitionUrlRaw(requestParameters: ImportApiDefinitionUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling importApiDefinitionUrl.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling importApiDefinitionUrl.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling importApiDefinitionUrl.');
        }

        const queryParameters: any = {};

        if (requestParameters.definitionVersion !== undefined) {
            queryParameters['definitionVersion'] = requestParameters.definitionVersion;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'text/plain';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/import-url`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * Create an API by importing an existing API definition via a URL
     * Create an API by importing a URL pointing to an API definition
     */
    async importApiDefinitionUrl(requestParameters: ImportApiDefinitionUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.importApiDefinitionUrlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must be ADMIN to use this service
     * Import pages
     */
    async importApiPageFilesRaw(requestParameters: ImportApiPageFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling importApiPageFiles.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling importApiPageFiles.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling importApiPageFiles.');
        }

        if (requestParameters.importPageEntity === null || requestParameters.importPageEntity === undefined) {
            throw new runtime.RequiredError('importPageEntity','Required parameter requestParameters.importPageEntity was null or undefined when calling importApiPageFiles.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages/_import`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImportPageEntityToJSON(requestParameters.importPageEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PageEntityFromJSON(jsonValue));
    }

    /**
     * User must be ADMIN to use this service
     * Import pages
     */
    async importApiPageFiles(requestParameters: ImportApiPageFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageEntity> {
        const response = await this.importApiPageFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Import path mappings from a page
     */
    async importApiPathMappingsFromPageRaw(requestParameters: ImportApiPathMappingsFromPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling importApiPathMappingsFromPage.');
        }

        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling importApiPathMappingsFromPage.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling importApiPathMappingsFromPage.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling importApiPathMappingsFromPage.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.definitionVersion !== undefined) {
            queryParameters['definitionVersion'] = requestParameters.definitionVersion;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/import-path-mappings`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Import path mappings from a page
     */
    async importApiPathMappingsFromPage(requestParameters: ImportApiPathMappingsFromPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.importApiPathMappingsFromPageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an API definition from a Swagger descriptor
     */
    async importSwaggerApiRaw(requestParameters: ImportSwaggerApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling importSwaggerApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling importSwaggerApi.');
        }

        if (requestParameters.importSwaggerDescriptorEntity === null || requestParameters.importSwaggerDescriptorEntity === undefined) {
            throw new runtime.RequiredError('importSwaggerDescriptorEntity','Required parameter requestParameters.importSwaggerDescriptorEntity was null or undefined when calling importSwaggerApi.');
        }

        const queryParameters: any = {};

        if (requestParameters.definitionVersion !== undefined) {
            queryParameters['definitionVersion'] = requestParameters.definitionVersion;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/import/swagger`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImportSwaggerDescriptorEntityToJSON(requestParameters.importSwaggerDescriptorEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * Create an API definition from a Swagger descriptor
     */
    async importSwaggerApi(requestParameters: ImportSwaggerApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.importSwaggerApiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_LIFECYCLE permission to use this service
     * Get the state of the API
     */
    async isApiSynchronizedRaw(requestParameters: IsApiSynchronizedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiStateEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling isApiSynchronized.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling isApiSynchronized.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling isApiSynchronized.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/state`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiStateEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_LIFECYCLE permission to use this service
     * Get the state of the API
     */
    async isApiSynchronized(requestParameters: IsApiSynchronizedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiStateEntity> {
        const response = await this.isApiSynchronizedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_API create permission to use this service
     * Migrate the API definition to be used with Policy Studio
     */
    async migrateAPIRaw(requestParameters: MigrateAPIRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling migrateAPI.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling migrateAPI.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling migrateAPI.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/_migrate`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_API create permission to use this service
     * Migrate the API definition to be used with Policy Studio
     */
    async migrateAPI(requestParameters: MigrateAPIRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.migrateAPIRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Update a page
     */
    async partialUpdateApiPageRaw(requestParameters: PartialUpdateApiPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageEntity>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling partialUpdateApiPage.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling partialUpdateApiPage.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling partialUpdateApiPage.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling partialUpdateApiPage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages/{page}`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdatePageEntityToJSON(requestParameters.updatePageEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PageEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Update a page
     */
    async partialUpdateApiPage(requestParameters: PartialUpdateApiPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageEntity> {
        const response = await this.partialUpdateApiPageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_DEFINITION[UPDATE] permission to use this service
     * Update the API with json patches
     */
    async patchRaw(requestParameters: PatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling patch.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling patch.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling patch.');
        }

        if (requestParameters.jsonPatch === null || requestParameters.jsonPatch === undefined) {
            throw new runtime.RequiredError('jsonPatch','Required parameter requestParameters.jsonPatch was null or undefined when calling patch.');
        }

        const queryParameters: any = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/definition`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.jsonPatch.map(JsonPatchToJSON),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * User must have the API_DEFINITION[UPDATE] permission to use this service
     * Update the API with json patches
     */
    async patch(requestParameters: PatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.patchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Update a subscription
     */
    async processApiSubscriptionRaw(requestParameters: ProcessApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.subscription === null || requestParameters.subscription === undefined) {
            throw new runtime.RequiredError('subscription','Required parameter requestParameters.subscription was null or undefined when calling processApiSubscription.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling processApiSubscription.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling processApiSubscription.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling processApiSubscription.');
        }

        if (requestParameters.processSubscriptionEntity === null || requestParameters.processSubscriptionEntity === undefined) {
            throw new runtime.RequiredError('processSubscriptionEntity','Required parameter requestParameters.processSubscriptionEntity was null or undefined when calling processApiSubscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions/{subscription}/_process`.replace(`{${"subscription"}}`, encodeURIComponent(String(requestParameters.subscription))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProcessSubscriptionEntityToJSON(requestParameters.processSubscriptionEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Update a subscription
     */
    async processApiSubscription(requestParameters: ProcessApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Subscription> {
        const response = await this.processApiSubscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_DEFINITION update permission to use this service
     * Promote the API to another environment
     */
    async promoteAPIRaw(requestParameters: PromoteAPIRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PromotionEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling promoteAPI.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling promoteAPI.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling promoteAPI.');
        }

        if (requestParameters.promotionRequestEntity === null || requestParameters.promotionRequestEntity === undefined) {
            throw new runtime.RequiredError('promotionRequestEntity','Required parameter requestParameters.promotionRequestEntity was null or undefined when calling promoteAPI.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/_promote`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PromotionRequestEntityToJSON(requestParameters.promotionRequestEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PromotionEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_DEFINITION update permission to use this service
     * Promote the API to another environment
     */
    async promoteAPI(requestParameters: PromoteAPIRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PromotionEntity> {
        const response = await this.promoteAPIRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Publicly publish plan
     */
    async publishApiPlanRaw(requestParameters: PublishApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlanEntity>> {
        if (requestParameters.plan === null || requestParameters.plan === undefined) {
            throw new runtime.RequiredError('plan','Required parameter requestParameters.plan was null or undefined when calling publishApiPlan.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling publishApiPlan.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling publishApiPlan.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling publishApiPlan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/plans/{plan}/_publish`.replace(`{${"plan"}}`, encodeURIComponent(String(requestParameters.plan))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlanEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Publicly publish plan
     */
    async publishApiPlan(requestParameters: PublishApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlanEntity> {
        const response = await this.publishApiPlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_SUBSCRIPTION permission to use this service
     * Reactivate an API key
     */
    async reactivateApiKeyForApiSubscriptionRaw(requestParameters: ReactivateApiKeyForApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.apikey === null || requestParameters.apikey === undefined) {
            throw new runtime.RequiredError('apikey','Required parameter requestParameters.apikey was null or undefined when calling reactivateApiKeyForApiSubscription.');
        }

        if (requestParameters.subscription === null || requestParameters.subscription === undefined) {
            throw new runtime.RequiredError('subscription','Required parameter requestParameters.subscription was null or undefined when calling reactivateApiKeyForApiSubscription.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling reactivateApiKeyForApiSubscription.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling reactivateApiKeyForApiSubscription.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling reactivateApiKeyForApiSubscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions/{subscription}/apikeys/{apikey}/_reactivate`.replace(`{${"apikey"}}`, encodeURIComponent(String(requestParameters.apikey))).replace(`{${"subscription"}}`, encodeURIComponent(String(requestParameters.subscription))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the API_SUBSCRIPTION permission to use this service
     * Reactivate an API key
     */
    async reactivateApiKeyForApiSubscription(requestParameters: ReactivateApiKeyForApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.reactivateApiKeyForApiSubscriptionRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the MANAGE_API_KEYS permission to use this service
     * Renew an API key
     */
    async renewSubscriptionApiKeysForApiSubscriptionRaw(requestParameters: RenewSubscriptionApiKeysForApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiKeyEntity>> {
        if (requestParameters.subscription === null || requestParameters.subscription === undefined) {
            throw new runtime.RequiredError('subscription','Required parameter requestParameters.subscription was null or undefined when calling renewSubscriptionApiKeysForApiSubscription.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling renewSubscriptionApiKeysForApiSubscription.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling renewSubscriptionApiKeysForApiSubscription.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling renewSubscriptionApiKeysForApiSubscription.');
        }

        const queryParameters: any = {};

        if (requestParameters.customApiKey !== undefined) {
            queryParameters['customApiKey'] = requestParameters.customApiKey;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions/{subscription}/apikeys/_renew`.replace(`{${"subscription"}}`, encodeURIComponent(String(requestParameters.subscription))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiKeyEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_API_KEYS permission to use this service
     * Renew an API key
     */
    async renewSubscriptionApiKeysForApiSubscription(requestParameters: RenewSubscriptionApiKeysForApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiKeyEntity> {
        const response = await this.renewSubscriptionApiKeysForApiSubscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_SUBSCRIPTION:DELETE permission to use this service
     * Revoke API key
     */
    async revokeApiKeyForApiSubscriptionRaw(requestParameters: RevokeApiKeyForApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.apikey === null || requestParameters.apikey === undefined) {
            throw new runtime.RequiredError('apikey','Required parameter requestParameters.apikey was null or undefined when calling revokeApiKeyForApiSubscription.');
        }

        if (requestParameters.subscription === null || requestParameters.subscription === undefined) {
            throw new runtime.RequiredError('subscription','Required parameter requestParameters.subscription was null or undefined when calling revokeApiKeyForApiSubscription.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling revokeApiKeyForApiSubscription.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling revokeApiKeyForApiSubscription.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling revokeApiKeyForApiSubscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions/{subscription}/apikeys/{apikey}`.replace(`{${"apikey"}}`, encodeURIComponent(String(requestParameters.apikey))).replace(`{${"subscription"}}`, encodeURIComponent(String(requestParameters.subscription))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the API_SUBSCRIPTION:DELETE permission to use this service
     * Revoke API key
     */
    async revokeApiKeyForApiSubscription(requestParameters: RevokeApiKeyForApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokeApiKeyForApiSubscriptionRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the MANAGE_LIFECYCLE permission to use this service
     * Rollback API to a previous version
     */
    async rollbackApiRaw(requestParameters: RollbackApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling rollbackApi.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling rollbackApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling rollbackApi.');
        }

        if (requestParameters.rollbackApiEntity === null || requestParameters.rollbackApiEntity === undefined) {
            throw new runtime.RequiredError('rollbackApiEntity','Required parameter requestParameters.rollbackApiEntity was null or undefined when calling rollbackApi.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/rollback`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RollbackApiEntityToJSON(requestParameters.rollbackApiEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_LIFECYCLE permission to use this service
     * Rollback API to a previous version
     */
    async rollbackApi(requestParameters: RollbackApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.rollbackApiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_EVENT[READ] permission to use this service
     * Get API\'s events
     */
    async searchApiEventsRaw(requestParameters: SearchApiEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EventEntityPage>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling searchApiEvents.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling searchApiEvents.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling searchApiEvents.');
        }

        const queryParameters: any = {};

        if (requestParameters.type) {
            queryParameters['type'] = requestParameters.type.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.to !== undefined) {
            queryParameters['to'] = requestParameters.to;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.apiIds) {
            queryParameters['api_ids'] = requestParameters.apiIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/events/search`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventEntityPageFromJSON(jsonValue));
    }

    /**
     * User must have the API_EVENT[READ] permission to use this service
     * Get API\'s events
     */
    async searchApiEvents(requestParameters: SearchApiEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EventEntityPage> {
        const response = await this.searchApiEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for API using the search engine
     */
    async searchApisRaw(requestParameters: SearchApisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApiListItem>>> {
        if (requestParameters.q === null || requestParameters.q === undefined) {
            throw new runtime.RequiredError('q','Required parameter requestParameters.q was null or undefined when calling searchApis.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling searchApis.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling searchApis.');
        }

        const queryParameters: any = {};

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/_search`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApiListItemFromJSON));
    }

    /**
     * Search for API using the search engine
     */
    async searchApis(requestParameters: SearchApisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApiListItem>> {
        const response = await this.searchApisRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for API using the search engine
     */
    async searchPagedApisRaw(requestParameters: SearchPagedApisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiListItem>> {
        if (requestParameters.q === null || requestParameters.q === undefined) {
            throw new runtime.RequiredError('q','Required parameter requestParameters.q was null or undefined when calling searchPagedApis.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling searchPagedApis.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling searchPagedApis.');
        }

        const queryParameters: any = {};

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/_search/_paged`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiListItemFromJSON(jsonValue));
    }

    /**
     * Search for API using the search engine
     */
    async searchPagedApis(requestParameters: SearchPagedApisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiListItem> {
        const response = await this.searchPagedApisRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the TRANSFER_OWNERSHIP permission to use this service
     * Transfer the ownership of the API
     */
    async transferApiMemberOwnershipRaw(requestParameters: TransferApiMemberOwnershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling transferApiMemberOwnership.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling transferApiMemberOwnership.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling transferApiMemberOwnership.');
        }

        if (requestParameters.transferOwnership === null || requestParameters.transferOwnership === undefined) {
            throw new runtime.RequiredError('transferOwnership','Required parameter requestParameters.transferOwnership was null or undefined when calling transferApiMemberOwnership.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/members/transfer_ownership`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransferOwnershipToJSON(requestParameters.transferOwnership),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the TRANSFER_OWNERSHIP permission to use this service
     * Transfer the ownership of the API
     */
    async transferApiMemberOwnership(requestParameters: TransferApiMemberOwnershipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.transferApiMemberOwnershipRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the API_SUBSCRIPTION update permission to use this service
     * Transfer a subscription
     */
    async transferApiSubscriptionRaw(requestParameters: TransferApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.subscription === null || requestParameters.subscription === undefined) {
            throw new runtime.RequiredError('subscription','Required parameter requestParameters.subscription was null or undefined when calling transferApiSubscription.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling transferApiSubscription.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling transferApiSubscription.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling transferApiSubscription.');
        }

        if (requestParameters.transferSubscriptionEntity === null || requestParameters.transferSubscriptionEntity === undefined) {
            throw new runtime.RequiredError('transferSubscriptionEntity','Required parameter requestParameters.transferSubscriptionEntity was null or undefined when calling transferApiSubscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions/{subscription}/_transfer`.replace(`{${"subscription"}}`, encodeURIComponent(String(requestParameters.subscription))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransferSubscriptionEntityToJSON(requestParameters.transferSubscriptionEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * User must have the API_SUBSCRIPTION update permission to use this service
     * Transfer a subscription
     */
    async transferApiSubscription(requestParameters: TransferApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Subscription> {
        const response = await this.transferApiSubscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Update the API
     */
    async updateApiRaw(requestParameters: UpdateApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApi.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApi.');
        }

        if (requestParameters.updateApiEntity === null || requestParameters.updateApiEntity === undefined) {
            throw new runtime.RequiredError('updateApiEntity','Required parameter requestParameters.updateApiEntity was null or undefined when calling updateApi.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateApiEntityToJSON(requestParameters.updateApiEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Update the API
     */
    async updateApi(requestParameters: UpdateApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.updateApiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_ALERT[UPDATE] permission to use this service
     * Update an alert for an API
     */
    async updateApiAlertRaw(requestParameters: UpdateApiAlertRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertTriggerEntity>> {
        if (requestParameters.alert === null || requestParameters.alert === undefined) {
            throw new runtime.RequiredError('alert','Required parameter requestParameters.alert was null or undefined when calling updateApiAlert.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiAlert.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiAlert.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiAlert.');
        }

        if (requestParameters.updateAlertTriggerEntity === null || requestParameters.updateAlertTriggerEntity === undefined) {
            throw new runtime.RequiredError('updateAlertTriggerEntity','Required parameter requestParameters.updateAlertTriggerEntity was null or undefined when calling updateApiAlert.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/alerts/{alert}`.replace(`{${"alert"}}`, encodeURIComponent(String(requestParameters.alert))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAlertTriggerEntityToJSON(requestParameters.updateAlertTriggerEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertTriggerEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_ALERT[UPDATE] permission to use this service
     * Update an alert for an API
     */
    async updateApiAlert(requestParameters: UpdateApiAlertRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertTriggerEntity> {
        const response = await this.updateApiAlertRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update generic notification settings
     */
    async updateApiGeneralNotificationSettingsRaw(requestParameters: UpdateApiGeneralNotificationSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenericNotificationConfigEntity>> {
        if (requestParameters.notificationId === null || requestParameters.notificationId === undefined) {
            throw new runtime.RequiredError('notificationId','Required parameter requestParameters.notificationId was null or undefined when calling updateApiGeneralNotificationSettings.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiGeneralNotificationSettings.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiGeneralNotificationSettings.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiGeneralNotificationSettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/notificationsettings/{notificationId}`.replace(`{${"notificationId"}}`, encodeURIComponent(String(requestParameters.notificationId))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: GenericNotificationConfigEntityToJSON(requestParameters.genericNotificationConfigEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenericNotificationConfigEntityFromJSON(jsonValue));
    }

    /**
     * Update generic notification settings
     */
    async updateApiGeneralNotificationSettings(requestParameters: UpdateApiGeneralNotificationSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenericNotificationConfigEntity> {
        const response = await this.updateApiGeneralNotificationSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_SUBSCRIPTION:UPDATE permission to use this service
     * Update API Key
     */
    async updateApiKeyForApiSubscriptionRaw(requestParameters: UpdateApiKeyForApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiKeyEntity>> {
        if (requestParameters.apikey === null || requestParameters.apikey === undefined) {
            throw new runtime.RequiredError('apikey','Required parameter requestParameters.apikey was null or undefined when calling updateApiKeyForApiSubscription.');
        }

        if (requestParameters.subscription === null || requestParameters.subscription === undefined) {
            throw new runtime.RequiredError('subscription','Required parameter requestParameters.subscription was null or undefined when calling updateApiKeyForApiSubscription.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiKeyForApiSubscription.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiKeyForApiSubscription.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiKeyForApiSubscription.');
        }

        if (requestParameters.apiKeyEntity === null || requestParameters.apiKeyEntity === undefined) {
            throw new runtime.RequiredError('apiKeyEntity','Required parameter requestParameters.apiKeyEntity was null or undefined when calling updateApiKeyForApiSubscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions/{subscription}/apikeys/{apikey}`.replace(`{${"apikey"}}`, encodeURIComponent(String(requestParameters.apikey))).replace(`{${"subscription"}}`, encodeURIComponent(String(requestParameters.subscription))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ApiKeyEntityToJSON(requestParameters.apiKeyEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiKeyEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_SUBSCRIPTION:UPDATE permission to use this service
     * Update API Key
     */
    async updateApiKeyForApiSubscription(requestParameters: UpdateApiKeyForApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiKeyEntity> {
        const response = await this.updateApiKeyForApiSubscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_METADATA[UPDATE] permission to use this service
     * Update an API metadata
     */
    async updateApiMetadataRaw(requestParameters: UpdateApiMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiMetadataEntity>> {
        if (requestParameters.metadata === null || requestParameters.metadata === undefined) {
            throw new runtime.RequiredError('metadata','Required parameter requestParameters.metadata was null or undefined when calling updateApiMetadata.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiMetadata.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiMetadata.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiMetadata.');
        }

        if (requestParameters.updateApiMetadataEntity === null || requestParameters.updateApiMetadataEntity === undefined) {
            throw new runtime.RequiredError('updateApiMetadataEntity','Required parameter requestParameters.updateApiMetadataEntity was null or undefined when calling updateApiMetadata.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/metadata/{metadata}`.replace(`{${"metadata"}}`, encodeURIComponent(String(requestParameters.metadata))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateApiMetadataEntityToJSON(requestParameters.updateApiMetadataEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiMetadataEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_METADATA[UPDATE] permission to use this service
     * Update an API metadata
     */
    async updateApiMetadata(requestParameters: UpdateApiMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiMetadataEntity> {
        const response = await this.updateApiMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Update a page
     */
    async updateApiPageRaw(requestParameters: UpdateApiPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageEntity>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling updateApiPage.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiPage.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiPage.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiPage.');
        }

        if (requestParameters.updatePageEntity === null || requestParameters.updatePageEntity === undefined) {
            throw new runtime.RequiredError('updatePageEntity','Required parameter requestParameters.updatePageEntity was null or undefined when calling updateApiPage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages/{page}`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdatePageEntityToJSON(requestParameters.updatePageEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PageEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Update a page
     */
    async updateApiPage(requestParameters: UpdateApiPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageEntity> {
        const response = await this.updateApiPageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must be ADMIN to use this service
     * Import pages
     */
    async updateApiPageImportFilesRaw(requestParameters: UpdateApiPageImportFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiPageImportFiles.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiPageImportFiles.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiPageImportFiles.');
        }

        if (requestParameters.importPageEntity === null || requestParameters.importPageEntity === undefined) {
            throw new runtime.RequiredError('importPageEntity','Required parameter requestParameters.importPageEntity was null or undefined when calling updateApiPageImportFiles.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages/_import`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ImportPageEntityToJSON(requestParameters.importPageEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PageEntityFromJSON(jsonValue));
    }

    /**
     * User must be ADMIN to use this service
     * Import pages
     */
    async updateApiPageImportFiles(requestParameters: UpdateApiPageImportFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageEntity> {
        const response = await this.updateApiPageImportFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Update a plan
     */
    async updateApiPlanRaw(requestParameters: UpdateApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlanEntity>> {
        if (requestParameters.plan === null || requestParameters.plan === undefined) {
            throw new runtime.RequiredError('plan','Required parameter requestParameters.plan was null or undefined when calling updateApiPlan.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiPlan.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiPlan.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiPlan.');
        }

        if (requestParameters.updatePlanEntity === null || requestParameters.updatePlanEntity === undefined) {
            throw new runtime.RequiredError('updatePlanEntity','Required parameter requestParameters.updatePlanEntity was null or undefined when calling updateApiPlan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/plans/{plan}`.replace(`{${"plan"}}`, encodeURIComponent(String(requestParameters.plan))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdatePlanEntityToJSON(requestParameters.updatePlanEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlanEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Update a plan
     */
    async updateApiPlan(requestParameters: UpdateApiPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlanEntity> {
        const response = await this.updateApiPlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update portal notification settings
     */
    async updateApiPortalNotificationSettingsRaw(requestParameters: UpdateApiPortalNotificationSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PortalNotificationConfigEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiPortalNotificationSettings.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiPortalNotificationSettings.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiPortalNotificationSettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/notificationsettings`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PortalNotificationConfigEntityToJSON(requestParameters.portalNotificationConfigEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PortalNotificationConfigEntityFromJSON(jsonValue));
    }

    /**
     * Update portal notification settings
     */
    async updateApiPortalNotificationSettings(requestParameters: UpdateApiPortalNotificationSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PortalNotificationConfigEntity> {
        const response = await this.updateApiPortalNotificationSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_QUALITY_RULE[UPDATE] permission to use this service
     * Update an existing quality rules for an API
     */
    async updateApiQualityRuleRaw(requestParameters: UpdateApiQualityRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiQualityRuleEntity>> {
        if (requestParameters.qualityRule === null || requestParameters.qualityRule === undefined) {
            throw new runtime.RequiredError('qualityRule','Required parameter requestParameters.qualityRule was null or undefined when calling updateApiQualityRule.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiQualityRule.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiQualityRule.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiQualityRule.');
        }

        if (requestParameters.updateApiQualityRuleEntity === null || requestParameters.updateApiQualityRuleEntity === undefined) {
            throw new runtime.RequiredError('updateApiQualityRuleEntity','Required parameter requestParameters.updateApiQualityRuleEntity was null or undefined when calling updateApiQualityRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/quality-rules/{qualityRule}`.replace(`{${"qualityRule"}}`, encodeURIComponent(String(requestParameters.qualityRule))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateApiQualityRuleEntityToJSON(requestParameters.updateApiQualityRuleEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiQualityRuleEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_QUALITY_RULE[UPDATE] permission to use this service
     * Update an existing quality rules for an API
     */
    async updateApiQualityRule(requestParameters: UpdateApiQualityRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiQualityRuleEntity> {
        const response = await this.updateApiQualityRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_RATING[UPDATE] permission to use this service
     * Update an existing rating for an API
     */
    async updateApiRatingRaw(requestParameters: UpdateApiRatingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RatingEntity>> {
        if (requestParameters.rating === null || requestParameters.rating === undefined) {
            throw new runtime.RequiredError('rating','Required parameter requestParameters.rating was null or undefined when calling updateApiRating.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiRating.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiRating.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiRating.');
        }

        if (requestParameters.updateRatingEntity === null || requestParameters.updateRatingEntity === undefined) {
            throw new runtime.RequiredError('updateRatingEntity','Required parameter requestParameters.updateRatingEntity was null or undefined when calling updateApiRating.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/ratings/{rating}`.replace(`{${"rating"}}`, encodeURIComponent(String(requestParameters.rating))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateRatingEntityToJSON(requestParameters.updateRatingEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RatingEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_RATING[UPDATE] permission to use this service
     * Update an existing rating for an API
     */
    async updateApiRating(requestParameters: UpdateApiRatingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RatingEntity> {
        const response = await this.updateApiRatingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Update a subscription
     */
    async updateApiSubscriptionRaw(requestParameters: UpdateApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Subscription>> {
        if (requestParameters.subscription === null || requestParameters.subscription === undefined) {
            throw new runtime.RequiredError('subscription','Required parameter requestParameters.subscription was null or undefined when calling updateApiSubscription.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiSubscription.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiSubscription.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiSubscription.');
        }

        if (requestParameters.updateSubscriptionEntity === null || requestParameters.updateSubscriptionEntity === undefined) {
            throw new runtime.RequiredError('updateSubscriptionEntity','Required parameter requestParameters.updateSubscriptionEntity was null or undefined when calling updateApiSubscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions/{subscription}`.replace(`{${"subscription"}}`, encodeURIComponent(String(requestParameters.subscription))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateSubscriptionEntityToJSON(requestParameters.updateSubscriptionEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_PLANS permission to use this service
     * Update a subscription
     */
    async updateApiSubscription(requestParameters: UpdateApiSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Subscription> {
        const response = await this.updateApiSubscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Update the API with an existing API definition in JSON format either with json or via an URL
     */
    async updateApiWithDefinitionRaw(requestParameters: UpdateApiWithDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiWithDefinition.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiWithDefinition.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiWithDefinition.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateApiWithDefinition.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/import`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Update the API with an existing API definition in JSON format either with json or via an URL
     */
    async updateApiWithDefinition(requestParameters: UpdateApiWithDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.updateApiWithDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Update the API with an existing Swagger descriptor
     */
    async updateApiWithSwaggerPUTRaw(requestParameters: UpdateApiWithSwaggerPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiWithSwaggerPUT.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiWithSwaggerPUT.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiWithSwaggerPUT.');
        }

        if (requestParameters.importSwaggerDescriptorEntity === null || requestParameters.importSwaggerDescriptorEntity === undefined) {
            throw new runtime.RequiredError('importSwaggerDescriptorEntity','Required parameter requestParameters.importSwaggerDescriptorEntity was null or undefined when calling updateApiWithSwaggerPUT.');
        }

        const queryParameters: any = {};

        if (requestParameters.definitionVersion !== undefined) {
            queryParameters['definitionVersion'] = requestParameters.definitionVersion;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/import/swagger`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ImportSwaggerDescriptorEntityToJSON(requestParameters.importSwaggerDescriptorEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Update the API with an existing Swagger descriptor
     */
    async updateApiWithSwaggerPUT(requestParameters: UpdateApiWithSwaggerPUTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.updateApiWithSwaggerPUTRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Update the API with an existing API definition in JSON format either with json or via an URL
     */
    async updateApiWithUrlRaw(requestParameters: UpdateApiWithUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updateApiWithUrl.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateApiWithUrl.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateApiWithUrl.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateApiWithUrl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'text/plain';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/import-url`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * User must have the MANAGE_API permission to use this service
     * Update the API with an existing API definition in JSON format either with json or via an URL
     */
    async updateApiWithUrl(requestParameters: UpdateApiWithUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.updateApiWithUrlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Put the page\'s content
     */
    async updatePageContentRaw(requestParameters: UpdatePageContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling updatePageContent.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling updatePageContent.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updatePageContent.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updatePageContent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updatePageContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/pages/{page}/content`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))).replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the MANAGE_PAGES permission to use this service
     * Put the page\'s content
     */
    async updatePageContent(requestParameters: UpdatePageContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updatePageContentRaw(requestParameters, initOverrides);
    }

    /**
     * Update the API from the API definition in JSON format either with json or via an URL
     * Update the API from the API definition
     */
    async updateWithDefinitionRaw(requestParameters: UpdateWithDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateWithDefinition.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateWithDefinition.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateWithDefinition.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/import`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiEntityFromJSON(jsonValue));
    }

    /**
     * Update the API from the API definition in JSON format either with json or via an URL
     * Update the API from the API definition
     */
    async updateWithDefinition(requestParameters: UpdateWithDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiEntity> {
        const response = await this.updateWithDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_DOCUMENTATION[CREATE] permission to use this service
     * Create a media for an API
     */
    async uploadApiMediaImageRaw(requestParameters: UploadApiMediaImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageEntity>> {
        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling uploadApiMediaImage.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling uploadApiMediaImage.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling uploadApiMediaImage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', new Blob([JSON.stringify(FormDataBodyPartToJSON(requestParameters.file))], { type: "application/json", }));
                    }

        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/media/upload`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PageEntityFromJSON(jsonValue));
    }

    /**
     * User must have the API_DOCUMENTATION[CREATE] permission to use this service
     * Create a media for an API
     */
    async uploadApiMediaImage(requestParameters: UploadApiMediaImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageEntity> {
        const response = await this.uploadApiMediaImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check if an API match the following criteria
     */
    async verifyApiRaw(requestParameters: VerifyApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling verifyApi.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling verifyApi.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/verify`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VerifyApiParamToJSON(requestParameters.verifyApiParam),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Check if an API match the following criteria
     */
    async verifyApi(requestParameters: VerifyApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.verifyApiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the API_SUBSCRIPTION:READ permission to use this service
     * Check a subscription can be created with given api key, and application
     */
    async verifyApiKeyCreationRaw(requestParameters: VerifyApiKeyCreationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters.key === null || requestParameters.key === undefined) {
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling verifyApiKeyCreation.');
        }

        if (requestParameters.application === null || requestParameters.application === undefined) {
            throw new runtime.RequiredError('application','Required parameter requestParameters.application was null or undefined when calling verifyApiKeyCreation.');
        }

        if (requestParameters.api === null || requestParameters.api === undefined) {
            throw new runtime.RequiredError('api','Required parameter requestParameters.api was null or undefined when calling verifyApiKeyCreation.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling verifyApiKeyCreation.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling verifyApiKeyCreation.');
        }

        const queryParameters: any = {};

        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }

        if (requestParameters.application !== undefined) {
            queryParameters['application'] = requestParameters.application;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/apis/{api}/subscriptions/_canCreate`.replace(`{${"api"}}`, encodeURIComponent(String(requestParameters.api))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * User must have the API_SUBSCRIPTION:READ permission to use this service
     * Check a subscription can be created with given api key, and application
     */
    async verifyApiKeyCreation(requestParameters: VerifyApiKeyCreationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.verifyApiKeyCreationRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetApiSubscriptionsExpandEnum = {
    KEYS: 'keys',
    SECURITY: 'security'
} as const;
export type GetApiSubscriptionsExpandEnum = typeof GetApiSubscriptionsExpandEnum[keyof typeof GetApiSubscriptionsExpandEnum];
/**
 * @export
 */
export const GetApisExecutionModeEnum = {
    V3: 'V3',
    JUPITER: 'JUPITER'
} as const;
export type GetApisExecutionModeEnum = typeof GetApisExecutionModeEnum[keyof typeof GetApisExecutionModeEnum];
/**
 * @export
 */
export const GetApisPagedExecutionModeEnum = {
    V3: 'V3',
    JUPITER: 'JUPITER'
} as const;
export type GetApisPagedExecutionModeEnum = typeof GetApisPagedExecutionModeEnum[keyof typeof GetApisPagedExecutionModeEnum];
