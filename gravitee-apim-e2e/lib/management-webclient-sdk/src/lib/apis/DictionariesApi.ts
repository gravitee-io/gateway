/* tslint:disable */
/* eslint-disable */
/**
 * Gravitee.io - Management API
 * Some news resources are in alpha version. This implies that they are likely to be modified or even removed in future versions. They are marked with the ðŸ§ª symbol
 *
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DictionaryEntity,
  DictionaryListItem,
  LifecycleAction,
  NewDictionaryEntity,
  UpdateDictionaryEntity,
} from '../models';
import {
    DictionaryEntityFromJSON,
    DictionaryEntityToJSON,
    DictionaryListItemFromJSON,
    DictionaryListItemToJSON,
    LifecycleActionFromJSON,
    LifecycleActionToJSON,
    NewDictionaryEntityFromJSON,
    NewDictionaryEntityToJSON,
    UpdateDictionaryEntityFromJSON,
    UpdateDictionaryEntityToJSON,
} from '../models';

export interface CreateDictionaryRequest {
    envId: string;
    orgId: string;
    newDictionaryEntity: NewDictionaryEntity;
}

export interface DeleteDictionaryRequest {
    dictionary: string;
    envId: string;
    orgId: string;
}

export interface DeployDictionaryRequest {
    dictionary: string;
    envId: string;
    orgId: string;
}

export interface DoLifecycleActionRequest {
    action: LifecycleAction;
    dictionary: string;
    envId: string;
    orgId: string;
}

export interface GetDictionariesRequest {
    envId: string;
    orgId: string;
}

export interface GetDictionaryRequest {
    dictionary: string;
    envId: string;
    orgId: string;
}

export interface UndeployDictionaryRequest {
    dictionary: string;
    envId: string;
    orgId: string;
}

export interface UpdateDictionaryRequest {
    dictionary: string;
    envId: string;
    orgId: string;
    updateDictionaryEntity: UpdateDictionaryEntity;
}

/**
 * 
 */
export class DictionariesApi extends runtime.BaseAPI {

    /**
     * User must have the DICTIONARY[CREATE] permission to use this service
     * Create a dictionary
     */
    async createDictionaryRaw(requestParameters: CreateDictionaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DictionaryEntity>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling createDictionary.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling createDictionary.');
        }

        if (requestParameters.newDictionaryEntity === null || requestParameters.newDictionaryEntity === undefined) {
            throw new runtime.RequiredError('newDictionaryEntity','Required parameter requestParameters.newDictionaryEntity was null or undefined when calling createDictionary.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewDictionaryEntityToJSON(requestParameters.newDictionaryEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DictionaryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the DICTIONARY[CREATE] permission to use this service
     * Create a dictionary
     */
    async createDictionary(requestParameters: CreateDictionaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DictionaryEntity> {
        const response = await this.createDictionaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the DICTIONARY[DELETE] permission to use this service
     * Delete a dictionary
     */
    async deleteDictionaryRaw(requestParameters: DeleteDictionaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
            throw new runtime.RequiredError('dictionary','Required parameter requestParameters.dictionary was null or undefined when calling deleteDictionary.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deleteDictionary.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deleteDictionary.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries/{dictionary}`.replace(`{${"dictionary"}}`, encodeURIComponent(String(requestParameters.dictionary))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User must have the DICTIONARY[DELETE] permission to use this service
     * Delete a dictionary
     */
    async deleteDictionary(requestParameters: DeleteDictionaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteDictionaryRaw(requestParameters, initOverrides);
    }

    /**
     * User must have the DICTIONARY[UPDATE] permission to use this service
     * Deploy dictionary to API gateway
     */
    async deployDictionaryRaw(requestParameters: DeployDictionaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DictionaryEntity>> {
        if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
            throw new runtime.RequiredError('dictionary','Required parameter requestParameters.dictionary was null or undefined when calling deployDictionary.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling deployDictionary.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling deployDictionary.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries/{dictionary}/_deploy`.replace(`{${"dictionary"}}`, encodeURIComponent(String(requestParameters.dictionary))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DictionaryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the DICTIONARY[UPDATE] permission to use this service
     * Deploy dictionary to API gateway
     */
    async deployDictionary(requestParameters: DeployDictionaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DictionaryEntity> {
        const response = await this.deployDictionaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the DICTIONARY[LIFECYCLE] permission to use this service
     * Manage the dictionary\'s lifecycle
     */
    async doLifecycleActionRaw(requestParameters: DoLifecycleActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DictionaryEntity>> {
        if (requestParameters.action === null || requestParameters.action === undefined) {
            throw new runtime.RequiredError('action','Required parameter requestParameters.action was null or undefined when calling doLifecycleAction.');
        }

        if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
            throw new runtime.RequiredError('dictionary','Required parameter requestParameters.dictionary was null or undefined when calling doLifecycleAction.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling doLifecycleAction.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling doLifecycleAction.');
        }

        const queryParameters: any = {};

        if (requestParameters.action !== undefined) {
            queryParameters['action'] = requestParameters.action;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries/{dictionary}`.replace(`{${"dictionary"}}`, encodeURIComponent(String(requestParameters.dictionary))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DictionaryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the DICTIONARY[LIFECYCLE] permission to use this service
     * Manage the dictionary\'s lifecycle
     */
    async doLifecycleAction(requestParameters: DoLifecycleActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DictionaryEntity> {
        const response = await this.doLifecycleActionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the DICTIONARY[READ] permission to use this service
     * Get the list of global dictionaries
     */
    async getDictionariesRaw(requestParameters: GetDictionariesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DictionaryListItem>>> {
        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getDictionaries.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getDictionaries.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries`.replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DictionaryListItemFromJSON));
    }

    /**
     * User must have the DICTIONARY[READ] permission to use this service
     * Get the list of global dictionaries
     */
    async getDictionaries(requestParameters: GetDictionariesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DictionaryListItem>> {
        const response = await this.getDictionariesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the DICTIONARY[READ] permission to use this service
     * Get a dictionary
     */
    async getDictionaryRaw(requestParameters: GetDictionaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DictionaryEntity>> {
        if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
            throw new runtime.RequiredError('dictionary','Required parameter requestParameters.dictionary was null or undefined when calling getDictionary.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling getDictionary.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling getDictionary.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries/{dictionary}`.replace(`{${"dictionary"}}`, encodeURIComponent(String(requestParameters.dictionary))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DictionaryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the DICTIONARY[READ] permission to use this service
     * Get a dictionary
     */
    async getDictionary(requestParameters: GetDictionaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DictionaryEntity> {
        const response = await this.getDictionaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the DICTIONARY[UPDATE] permission to use this service
     * Undeploy dictionary to API gateway
     */
    async undeployDictionaryRaw(requestParameters: UndeployDictionaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DictionaryEntity>> {
        if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
            throw new runtime.RequiredError('dictionary','Required parameter requestParameters.dictionary was null or undefined when calling undeployDictionary.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling undeployDictionary.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling undeployDictionary.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries/{dictionary}/_undeploy`.replace(`{${"dictionary"}}`, encodeURIComponent(String(requestParameters.dictionary))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DictionaryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the DICTIONARY[UPDATE] permission to use this service
     * Undeploy dictionary to API gateway
     */
    async undeployDictionary(requestParameters: UndeployDictionaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DictionaryEntity> {
        const response = await this.undeployDictionaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User must have the DICTIONARY[UPDATE] permission to use this service
     * Update a dictionary
     */
    async updateDictionaryRaw(requestParameters: UpdateDictionaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DictionaryEntity>> {
        if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
            throw new runtime.RequiredError('dictionary','Required parameter requestParameters.dictionary was null or undefined when calling updateDictionary.');
        }

        if (requestParameters.envId === null || requestParameters.envId === undefined) {
            throw new runtime.RequiredError('envId','Required parameter requestParameters.envId was null or undefined when calling updateDictionary.');
        }

        if (requestParameters.orgId === null || requestParameters.orgId === undefined) {
            throw new runtime.RequiredError('orgId','Required parameter requestParameters.orgId was null or undefined when calling updateDictionary.');
        }

        if (requestParameters.updateDictionaryEntity === null || requestParameters.updateDictionaryEntity === undefined) {
            throw new runtime.RequiredError('updateDictionaryEntity','Required parameter requestParameters.updateDictionaryEntity was null or undefined when calling updateDictionary.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/organizations/{orgId}/environments/{envId}/configuration/dictionaries/{dictionary}`.replace(`{${"dictionary"}}`, encodeURIComponent(String(requestParameters.dictionary))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters.envId))).replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters.orgId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateDictionaryEntityToJSON(requestParameters.updateDictionaryEntity),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DictionaryEntityFromJSON(jsonValue));
    }

    /**
     * User must have the DICTIONARY[UPDATE] permission to use this service
     * Update a dictionary
     */
    async updateDictionary(requestParameters: UpdateDictionaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DictionaryEntity> {
        const response = await this.updateDictionaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
